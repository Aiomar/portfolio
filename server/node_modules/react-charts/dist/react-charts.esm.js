import React from 'react';
import now from 'performance-now';
import { curveMonotoneX, curveLinear as curveLinear$1 } from '@visx/curve';
import { ParentSize } from '@visx/responsive';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function buildStyleGetters(series, defaults) {
  series.getStatusStyle = function (focused, decorator) {
    var status = getStatus(series, focused);
    series.style = getStatusStyle(series, status, decorator, defaults);
    return series.style;
  }; // We also need to decorate each datum in the same fashion


  series.datums.forEach(function (datum) {
    datum.getStatusStyle = function (focused, decorator) {
      var status = getStatus(datum, focused);
      datum.style = getStatusStyle(datum, status, decorator, defaults);
      return datum.style;
    };
  });
}

function getStatusStyle(item, status, decorator, defaults) {
  if (item.series) {
    defaults = _extends({}, defaults, item.series.style);
  }

  return materializeStyles(decorator(_extends({}, item, status)), defaults);
}

function getStatus(item, focused) {
  var status = {
    focused: false,
    otherFocused: false
  };

  if (!focused) {
    return status;
  } // If the item is a datum


  if (typeof item.primary !== 'undefined') {
    var length = focused.group.length;

    for (var i = 0; i < length; i++) {
      if (focused.group[i].seriesId === item.series.id && focused.group[i].index === item.index) {
        status.focused = true;
        break;
      }
    }

    status.otherFocused = !status.focused; // For series
  } else if (focused.series) {
    status.focused = focused.series.id === item.id;
    status.otherFocused = !status.focused;
  }

  return status;
}

function normalizeColor(style, defaults) {
  return _extends({}, style, {
    stroke: style.stroke || style.color || defaults.stroke || defaults.color,
    fill: style.fill || style.color || defaults.fill || defaults.color
  });
}

var elementTypes = ['area', 'line', 'rectangle', 'circle'];

function materializeStyles(style, defaults) {
  if (style === void 0) {
    style = {};
  }

  if (defaults === void 0) {
    defaults = {};
  }

  style = normalizeColor(style, defaults);

  for (var i = 0; i < elementTypes.length; i++) {
    var type = elementTypes[i];

    if (style[type] && defaults[type]) {
      style[type] = materializeStyles(style[type], defaults);
    }
  }

  return style;
}

function isValidPoint(d) {
  if (d === null) {
    return false;
  }

  if (typeof d === 'undefined') {
    return false;
  }

  if (typeof d === 'string' && d === 'null') {
    return false;
  }

  return true;
}
function getClosestPoint(position, datums) {
  if (!datums || !position || !datums.length) {
    return;
  }

  var closestDistance = Infinity;
  var closestDatum = datums[0];
  datums.forEach(function (datum) {
    datum.boundingPoints.forEach(function (pointerPoint) {
      var distance = Math.sqrt(Math.pow(pointerPoint.x - position.x, 2) + Math.pow(pointerPoint.y - position.y, 2));

      if (distance < closestDistance) {
        closestDistance = distance;
        closestDatum = datum;
      }
    });
  });
  return closestDatum;
}
function getAxisByAxisId(axes, AxisId) {
  return axes.find(function (d) {
    return d.id === AxisId;
  }) || axes[0];
}
function getAxisIndexByAxisId(axes, AxisId) {
  var index = axes.findIndex(function (d) {
    return d.id === AxisId;
  });
  return index > -1 ? index : 0;
}
function translateX(x) {
  return "translate3d(" + Math.round(x) + "px, 0, 0)";
}
function translateY(y) {
  return "translate3d(0, " + Math.round(y) + "px, 0)";
}
function translate(x, y) {
  return "translate3d(" + Math.round(x) + "px, " + Math.round(y) + "px, 0)";
}
function identity(d) {
  return d;
}
function functionalUpdate(updater, old) {
  return typeof updater === 'function' ? updater(old) : updater;
}

function useGetLatest(obj) {
  var ref = React.useRef();
  var getterRef = React.useRef();
  ref.current = obj;

  if (!getterRef.current) {
    getterRef.current = function () {
      return ref.current;
    };
  }

  return getterRef.current;
}

function useLatest(obj, when) {
  if (when === void 0) {
    when = true;
  }

  var ref = React.useRef();

  if (when) {
    ref.current = obj;
  }

  return ref.current;
}

function usePrevious(val) {
  var ref = React.useRef();
  React.useEffect(function () {
    ref.current = val;
  }, [val]);
  return ref.current;
}

var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;

var chartContext = /*#__PURE__*/React.createContext();
function createChartState(initialState) {
  var listeners = [];
  var api = {};

  api.setState = function (updater) {
    var newState = functionalUpdate(updater, api.state);

    if (api.state === newState) {
      return;
    }

    api.state = newState;
    listeners.forEach(function (d) {
      return d();
    });
  };

  api.state = functionalUpdate(initialState, api.setState);

  api.subscribe = function (cb) {
    listeners.push(cb);
    return function () {
      return listeners = listeners.filter(function (d) {
        return d !== cb;
      });
    };
  };

  api.Provider = function (_ref) {
    var children = _ref.children;
    return React.createElement(chartContext.Provider, {
      value: api,
      children: children
    });
  };

  return api;
}
function useChartState(selector, eqType) {
  if (eqType === void 0) {
    eqType = undefined;
  }

  var apiInstance = React.useContext(chartContext);

  var _React$useReducer = React.useReducer(function (d) {
    return d + 1;
  }, 0),
      rerender = _React$useReducer[1];

  var slice = selector ? selector(apiInstance.state) : apiInstance.state;
  var valueRef = React.useRef(slice);
  var getSelector = useGetLatest(selector);
  var getEqType = useGetLatest(eqType);
  useIsomorphicLayoutEffect(function () {
    return apiInstance.subscribe(function () {
      var selector = getSelector();
      var eqType = getEqType();
      var slice = selector ? selector(apiInstance.state) : apiInstance.state;
      var eqFn = eqType === 'shallow' ? shallowEq : Object.is;

      if (!eqFn(valueRef.current, slice)) {
        valueRef.current = slice;
        rerender();
      }
    });
  }, [getSelector, getEqType]);
  return [valueRef.current, apiInstance.setState];
}

function shallowEq(a, b) {
  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);

  if (aKeys.length !== bKeys.length) {
    return false;
  }

  if (Object.keys(aKeys).some(function (key) {
    return a[key] !== b[key];
  })) {
    return false;
  }
}

var chartContext$1 = /*#__PURE__*/React.createContext();
function ChartContextProvider(_ref) {
  var value = _ref.value,
      children = _ref.children;
  var getValue = useGetLatest(value);
  return React.createElement(chartContext$1.Provider, {
    value: getValue,
    children: children
  });
}
function useChartContext() {
  return React.useContext(chartContext$1)();
}

var root = typeof window === 'undefined' ? global : window,
    vendors = ['moz', 'webkit'],
    suffix = 'AnimationFrame',
    raf = root['request' + suffix],
    caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

for (var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix] || root[vendors[i] + 'CancelRequest' + suffix];
} // Some versions of FF have rAF but not cAF


if (!raf || !caf) {
  var last = 0,
      id = 0,
      queue = [],
      frameDuration = 1000 / 60;

  raf = function raf(callback) {
    if (queue.length === 0) {
      var _now = now(),
          next = Math.max(0, frameDuration - (_now - last));

      last = next + _now;
      setTimeout(function () {
        var cp = queue.slice(0); // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue

        queue.length = 0;

        for (var i = 0; i < cp.length; i++) {
          if (!cp[i].cancelled) {
            try {
              cp[i].callback(last);
            } catch (e) {
              setTimeout(function () {
                throw e;
              }, 0);
            }
          }
        }
      }, Math.round(next));
    }

    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id;
  };

  caf = function caf(handle) {
    for (var i = 0; i < queue.length; i++) {
      if (queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}

function Raf(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn);
}

Raf.cancel = function () {
  caf.apply(root, arguments);
};

Raf.polyfill = function (object) {
  if (!object) {
    object = root;
  }

  object.requestAnimationFrame = raf;
  object.cancelAnimationFrame = caf;
};

var defaultStyle = {
  strokeWidth: 0,
  fill: '#333',
  opacity: 1,
  rx: 0,
  ry: 0
};
var Rectangle = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var style = _ref.style,
      x1 = _ref.x1,
      y1 = _ref.y1,
      x2 = _ref.x2,
      y2 = _ref.y2,
      rest = _objectWithoutPropertiesLoose(_ref, ["style", "opacity", "x1", "y1", "x2", "y2"]);

  var resolvedStyle = _extends({}, defaultStyle, style);

  var xStart = Math.min(x1, x2);
  var yStart = Math.min(y1, y2);
  var xEnd = Math.max(x1, x2);
  var yEnd = Math.max(y1, y2);
  var height = Math.max(yEnd - yStart, 0);
  var width = Math.max(xEnd - xStart, 0);
  return React.createElement("rect", Object.assign({
    ref: ref
  }, rest, {
    x: xStart,
    y: yStart,
    width: width,
    height: height,
    style: resolvedStyle
  }));
});

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}
});

var _marked = /*#__PURE__*/runtime_1.mark(flatIterable);
var EPSILON = /*#__PURE__*/Math.pow(2, -52);
var EDGE_STACK = /*#__PURE__*/new Uint32Array(512);

var Delaunator = /*#__PURE__*/function () {
  Delaunator.from = function from(points, getX, getY) {
    if (getX === void 0) {
      getX = defaultGetX;
    }

    if (getY === void 0) {
      getY = defaultGetY;
    }

    var n = points.length;
    var coords = new Float64Array(n * 2);

    for (var i = 0; i < n; i++) {
      var p = points[i];
      coords[2 * i] = getX(p);
      coords[2 * i + 1] = getY(p);
    }

    return new Delaunator(coords);
  };

  function Delaunator(coords) {
    var n = coords.length >> 1;
    if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');
    this.coords = coords; // arrays that will store the triangulation graph

    var maxTriangles = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(maxTriangles * 3);
    this._halfedges = new Int32Array(maxTriangles * 3); // temporary arrays for tracking the edges of the advancing convex hull

    this._hashSize = Math.ceil(Math.sqrt(n));
    this._hullPrev = new Uint32Array(n); // edge to prev edge

    this._hullNext = new Uint32Array(n); // edge to next edge

    this._hullTri = new Uint32Array(n); // edge to adjacent triangle

    this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash
    // temporary arrays for sorting points

    this._ids = new Uint32Array(n);
    this._dists = new Float64Array(n);
    this.update();
  }

  var _proto = Delaunator.prototype;

  _proto.update = function update() {
    var coords = this.coords,
        hullPrev = this._hullPrev,
        hullNext = this._hullNext,
        hullTri = this._hullTri,
        hullHash = this._hullHash;
    var n = coords.length >> 1; // populate an array of point indices; calculate input data bbox

    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;

    for (var i = 0; i < n; i++) {
      var _x = coords[2 * i];
      var _y = coords[2 * i + 1];
      if (_x < minX) minX = _x;
      if (_y < minY) minY = _y;
      if (_x > maxX) maxX = _x;
      if (_y > maxY) maxY = _y;
      this._ids[i] = i;
    }

    var cx = (minX + maxX) / 2;
    var cy = (minY + maxY) / 2;
    var minDist = Infinity;
    var i0, i1, i2; // pick a seed point close to the center

    for (var _i = 0; _i < n; _i++) {
      var d = dist(cx, cy, coords[2 * _i], coords[2 * _i + 1]);

      if (d < minDist) {
        i0 = _i;
        minDist = d;
      }
    }

    var i0x = coords[2 * i0];
    var i0y = coords[2 * i0 + 1];
    minDist = Infinity; // find the point closest to the seed

    for (var _i2 = 0; _i2 < n; _i2++) {
      if (_i2 === i0) continue;

      var _d = dist(i0x, i0y, coords[2 * _i2], coords[2 * _i2 + 1]);

      if (_d < minDist && _d > 0) {
        i1 = _i2;
        minDist = _d;
      }
    }

    var i1x = coords[2 * i1];
    var i1y = coords[2 * i1 + 1];
    var minRadius = Infinity; // find the third point which forms the smallest circumcircle with the first two

    for (var _i3 = 0; _i3 < n; _i3++) {
      if (_i3 === i0 || _i3 === i1) continue;
      var r = circumradius(i0x, i0y, i1x, i1y, coords[2 * _i3], coords[2 * _i3 + 1]);

      if (r < minRadius) {
        i2 = _i3;
        minRadius = r;
      }
    }

    var i2x = coords[2 * i2];
    var i2y = coords[2 * i2 + 1];

    if (minRadius === Infinity) {
      // order collinear points by dx (or dy if all x are identical)
      // and return the list as a hull
      for (var _i4 = 0; _i4 < n; _i4++) {
        this._dists[_i4] = coords[2 * _i4] - coords[0] || coords[2 * _i4 + 1] - coords[1];
      }

      quicksort(this._ids, this._dists, 0, n - 1);
      var hull = new Uint32Array(n);
      var j = 0;

      for (var _i5 = 0, d0 = -Infinity; _i5 < n; _i5++) {
        var id = this._ids[_i5];

        if (this._dists[id] > d0) {
          hull[j++] = id;
          d0 = this._dists[id];
        }
      }

      this.hull = hull.subarray(0, j);
      this.triangles = new Uint32Array(0);
      this.halfedges = new Uint32Array(0);
      return;
    } // swap the order of the seed points for counter-clockwise orientation


    if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {
      var _i6 = i1;
      var _x2 = i1x;
      var _y2 = i1y;
      i1 = i2;
      i1x = i2x;
      i1y = i2y;
      i2 = _i6;
      i2x = _x2;
      i2y = _y2;
    }

    var center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
    this._cx = center.x;
    this._cy = center.y;

    for (var _i7 = 0; _i7 < n; _i7++) {
      this._dists[_i7] = dist(coords[2 * _i7], coords[2 * _i7 + 1], center.x, center.y);
    } // sort the points by distance from the seed triangle circumcenter


    quicksort(this._ids, this._dists, 0, n - 1); // set up the seed triangle as the starting hull

    this._hullStart = i0;
    var hullSize = 3;
    hullNext[i0] = hullPrev[i2] = i1;
    hullNext[i1] = hullPrev[i0] = i2;
    hullNext[i2] = hullPrev[i1] = i0;
    hullTri[i0] = 0;
    hullTri[i1] = 1;
    hullTri[i2] = 2;
    hullHash.fill(-1);
    hullHash[this._hashKey(i0x, i0y)] = i0;
    hullHash[this._hashKey(i1x, i1y)] = i1;
    hullHash[this._hashKey(i2x, i2y)] = i2;
    this.trianglesLen = 0;

    this._addTriangle(i0, i1, i2, -1, -1, -1);

    for (var k = 0, xp, yp; k < this._ids.length; k++) {
      var _i8 = this._ids[k];
      var _x3 = coords[2 * _i8];
      var _y3 = coords[2 * _i8 + 1]; // skip near-duplicate points

      if (k > 0 && Math.abs(_x3 - xp) <= EPSILON && Math.abs(_y3 - yp) <= EPSILON) continue;
      xp = _x3;
      yp = _y3; // skip seed triangle points

      if (_i8 === i0 || _i8 === i1 || _i8 === i2) continue; // find a visible edge on the convex hull using edge hash

      var start = 0;

      for (var _j = 0, key = this._hashKey(_x3, _y3); _j < this._hashSize; _j++) {
        start = hullHash[(key + _j) % this._hashSize];
        if (start !== -1 && start !== hullNext[start]) break;
      }

      start = hullPrev[start];
      var e = start,
          q = void 0;

      while (q = hullNext[e], !orient(_x3, _y3, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {
        e = q;

        if (e === start) {
          e = -1;
          break;
        }
      }

      if (e === -1) continue; // likely a near-duplicate point; skip it
      // add the first triangle from the point

      var t = this._addTriangle(e, _i8, hullNext[e], -1, -1, hullTri[e]); // recursively flip triangles from the point until they satisfy the Delaunay condition


      hullTri[_i8] = this._legalize(t + 2);
      hullTri[e] = t; // keep track of boundary triangles on the hull

      hullSize++; // walk forward through the hull, adding more triangles and flipping recursively

      var _n = hullNext[e];

      while (q = hullNext[_n], orient(_x3, _y3, coords[2 * _n], coords[2 * _n + 1], coords[2 * q], coords[2 * q + 1])) {
        t = this._addTriangle(_n, _i8, q, hullTri[_i8], -1, hullTri[_n]);
        hullTri[_i8] = this._legalize(t + 2);
        hullNext[_n] = _n; // mark as removed

        hullSize--;
        _n = q;
      } // walk backward from the other side, adding more triangles and flipping


      if (e === start) {
        while (q = hullPrev[e], orient(_x3, _y3, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {
          t = this._addTriangle(q, _i8, e, -1, hullTri[e], hullTri[q]);

          this._legalize(t + 2);

          hullTri[q] = t;
          hullNext[e] = e; // mark as removed

          hullSize--;
          e = q;
        }
      } // update the hull indices


      this._hullStart = hullPrev[_i8] = e;
      hullNext[e] = hullPrev[_n] = _i8;
      hullNext[_i8] = _n; // save the two new edges in the hash table

      hullHash[this._hashKey(_x3, _y3)] = _i8;
      hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
    }

    this.hull = new Uint32Array(hullSize);

    for (var _i9 = 0, _e = this._hullStart; _i9 < hullSize; _i9++) {
      this.hull[_i9] = _e;
      _e = hullNext[_e];
    } // trim typed triangle mesh arrays


    this.triangles = this._triangles.subarray(0, this.trianglesLen);
    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  };

  _proto._hashKey = function _hashKey(x, y) {
    return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
  };

  _proto._legalize = function _legalize(a) {
    var triangles = this._triangles,
        halfedges = this._halfedges,
        coords = this.coords;
    var i = 0;
    var ar = 0; // recursion eliminated with a fixed-size stack

    while (true) {
      var b = halfedges[a];
      /* if the pair of triangles doesn't satisfy the Delaunay condition
       * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
       * then do the same check/flip recursively for the new pair of triangles
       *
       *           pl                    pl
       *          /||\                  /  \
       *       al/ || \bl            al/    \a
       *        /  ||  \              /      \
       *       /  a||b  \    flip    /___ar___\
       *     p0\   ||   /p1   =>   p0\---bl---/p1
       *        \  ||  /              \      /
       *       ar\ || /br             b\    /br
       *          \||/                  \  /
       *           pr                    pr
       */

      var a0 = a - a % 3;
      ar = a0 + (a + 2) % 3;

      if (b === -1) {
        // convex hull edge
        if (i === 0) break;
        a = EDGE_STACK[--i];
        continue;
      }

      var b0 = b - b % 3;
      var al = a0 + (a + 1) % 3;
      var bl = b0 + (b + 2) % 3;
      var p0 = triangles[ar];
      var pr = triangles[a];
      var pl = triangles[al];
      var p1 = triangles[bl];
      var illegal = inCircle(coords[2 * p0], coords[2 * p0 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1]);

      if (illegal) {
        triangles[a] = p1;
        triangles[b] = p0;
        var hbl = halfedges[bl]; // edge swapped on the other side of the hull (rare); fix the halfedge reference

        if (hbl === -1) {
          var e = this._hullStart;

          do {
            if (this._hullTri[e] === bl) {
              this._hullTri[e] = a;
              break;
            }

            e = this._hullPrev[e];
          } while (e !== this._hullStart);
        }

        this._link(a, hbl);

        this._link(b, halfedges[ar]);

        this._link(ar, bl);

        var br = b0 + (b + 1) % 3; // don't worry about hitting the cap: it can only happen on extremely degenerate input

        if (i < EDGE_STACK.length) {
          EDGE_STACK[i++] = br;
        }
      } else {
        if (i === 0) break;
        a = EDGE_STACK[--i];
      }
    }

    return ar;
  };

  _proto._link = function _link(a, b) {
    this._halfedges[a] = b;
    if (b !== -1) this._halfedges[b] = a;
  } // add a new triangle given vertex indices and adjacent half-edge ids
  ;

  _proto._addTriangle = function _addTriangle(i0, i1, i2, a, b, c) {
    var t = this.trianglesLen;
    this._triangles[t] = i0;
    this._triangles[t + 1] = i1;
    this._triangles[t + 2] = i2;

    this._link(t, a);

    this._link(t + 1, b);

    this._link(t + 2, c);

    this.trianglesLen += 3;
    return t;
  };

  return Delaunator;
}(); // monotonically increases with real angle, but doesn't need expensive trigonometry


function pseudoAngle(dx, dy) {
  var p = dx / (Math.abs(dx) + Math.abs(dy));
  return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
}

function dist(ax, ay, bx, by) {
  var dx = ax - bx;
  var dy = ay - by;
  return dx * dx + dy * dy;
} // return 2d orientation sign if we're confident in it through J. Shewchuk's error bound check


function orientIfSure(px, py, rx, ry, qx, qy) {
  var l = (ry - py) * (qx - px);
  var r = (rx - px) * (qy - py);
  return Math.abs(l - r) >= 3.3306690738754716e-16 * Math.abs(l + r) ? l - r : 0;
} // a more robust orientation test that's stable in a given triangle (to fix robustness issues)


function orient(rx, ry, qx, qy, px, py) {
  var sign = orientIfSure(px, py, rx, ry, qx, qy) || orientIfSure(rx, ry, qx, qy, px, py) || orientIfSure(qx, qy, px, py, rx, ry);
  return sign < 0;
}

function inCircle(ax, ay, bx, by, cx, cy, px, py) {
  var dx = ax - px;
  var dy = ay - py;
  var ex = bx - px;
  var ey = by - py;
  var fx = cx - px;
  var fy = cy - py;
  var ap = dx * dx + dy * dy;
  var bp = ex * ex + ey * ey;
  var cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}

function circumradius(ax, ay, bx, by, cx, cy) {
  var dx = bx - ax;
  var dy = by - ay;
  var ex = cx - ax;
  var ey = cy - ay;
  var bl = dx * dx + dy * dy;
  var cl = ex * ex + ey * ey;
  var d = 0.5 / (dx * ey - dy * ex);
  var x = (ey * bl - dy * cl) * d;
  var y = (dx * cl - ex * bl) * d;
  return x * x + y * y;
}

function circumcenter(ax, ay, bx, by, cx, cy) {
  var dx = bx - ax;
  var dy = by - ay;
  var ex = cx - ax;
  var ey = cy - ay;
  var bl = dx * dx + dy * dy;
  var cl = ex * ex + ey * ey;
  var d = 0.5 / (dx * ey - dy * ex);
  var x = ax + (ey * bl - dy * cl) * d;
  var y = ay + (dx * cl - ex * bl) * d;
  return {
    x: x,
    y: y
  };
}

function quicksort(ids, dists, left, right) {
  if (right - left <= 20) {
    for (var i = left + 1; i <= right; i++) {
      var temp = ids[i];
      var tempDist = dists[temp];
      var j = i - 1;

      while (j >= left && dists[ids[j]] > tempDist) {
        ids[j + 1] = ids[j--];
      }

      ids[j + 1] = temp;
    }
  } else {
    var median = left + right >> 1;

    var _i10 = left + 1;

    var _j2 = right;
    swap(ids, median, _i10);
    if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
    if (dists[ids[_i10]] > dists[ids[right]]) swap(ids, _i10, right);
    if (dists[ids[left]] > dists[ids[_i10]]) swap(ids, left, _i10);
    var _temp = ids[_i10];
    var _tempDist = dists[_temp];

    while (true) {
      do {
        _i10++;
      } while (dists[ids[_i10]] < _tempDist);

      do {
        _j2--;
      } while (dists[ids[_j2]] > _tempDist);

      if (_j2 < _i10) break;
      swap(ids, _i10, _j2);
    }

    ids[left + 1] = ids[_j2];
    ids[_j2] = _temp;

    if (right - _i10 + 1 >= _j2 - left) {
      quicksort(ids, dists, _i10, right);
      quicksort(ids, dists, left, _j2 - 1);
    } else {
      quicksort(ids, dists, left, _j2 - 1);
      quicksort(ids, dists, _i10, right);
    }
  }
}

function swap(arr, i, j) {
  var tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}

function defaultGetX(p) {
  return p[0];
}

function defaultGetY(p) {
  return p[1];
}

var epsilon = 1e-6;

var Path = /*#__PURE__*/function () {
  function Path() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath

    this._ = "";
  }

  var _proto2 = Path.prototype;

  _proto2.moveTo = function moveTo(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  };

  _proto2.closePath = function closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  };

  _proto2.lineTo = function lineTo(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  };

  _proto2.arc = function arc(x, y, r) {
    x = +x, y = +y, r = +r;
    var x0 = x + r;
    var y0 = y;
    if (r < 0) throw new Error("negative radius");
    if (this._x1 === null) this._ += "M" + x0 + "," + y0;else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._ += "L" + x0 + "," + y0;
    if (!r) return;
    this._ += "A" + r + "," + r + ",0,1,1," + (x - r) + "," + y + "A" + r + "," + r + ",0,1,1," + (this._x1 = x0) + "," + (this._y1 = y0);
  };

  _proto2.rect = function rect(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + +w + "v" + +h + "h" + -w + "Z";
  };

  _proto2.value = function value() {
    return this._ || null;
  };

  return Path;
}();

var Polygon = /*#__PURE__*/function () {
  function Polygon() {
    this._ = [];
  }

  var _proto3 = Polygon.prototype;

  _proto3.moveTo = function moveTo(x, y) {
    this._.push([x, y]);
  };

  _proto3.closePath = function closePath() {
    this._.push(this._[0].slice());
  };

  _proto3.lineTo = function lineTo(x, y) {
    this._.push([x, y]);
  };

  _proto3.value = function value() {
    return this._.length ? this._ : null;
  };

  return Polygon;
}();

var Voronoi = /*#__PURE__*/function () {
  function Voronoi(delaunay, _temp2) {
    var _ref = _temp2 === void 0 ? [0, 0, 960, 500] : _temp2,
        xmin = _ref[0],
        ymin = _ref[1],
        xmax = _ref[2],
        ymax = _ref[3];

    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;

    this._init();
  }

  var _proto4 = Voronoi.prototype;

  _proto4.update = function update() {
    this.delaunay.update();

    this._init();

    return this;
  };

  _proto4._init = function _init() {
    var _this$delaunay = this.delaunay,
        points = _this$delaunay.points,
        hull = _this$delaunay.hull,
        triangles = _this$delaunay.triangles,
        vectors = this.vectors; // Compute circumcenters.

    var circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);

    for (var i = 0, j = 0, n = triangles.length, _x4, _y4; i < n; i += 3, j += 2) {
      var _t = triangles[i] * 2;

      var t2 = triangles[i + 1] * 2;
      var t3 = triangles[i + 2] * 2;
      var _x5 = points[_t];
      var _y5 = points[_t + 1];
      var x2 = points[t2];
      var y2 = points[t2 + 1];
      var x3 = points[t3];
      var y3 = points[t3 + 1];
      var dx = x2 - _x5;
      var dy = y2 - _y5;
      var ex = x3 - _x5;
      var ey = y3 - _y5;
      var bl = dx * dx + dy * dy;
      var cl = ex * ex + ey * ey;
      var ab = (dx * ey - dy * ex) * 2;

      if (!ab) {
        // degenerate case (collinear diagram)
        _x4 = (_x5 + x3) / 2 - 1e8 * ey;
        _y4 = (_y5 + y3) / 2 + 1e8 * ex;
      } else if (Math.abs(ab) < 1e-8) {
        // almost equal points (degenerate triangle)
        _x4 = (_x5 + x3) / 2;
        _y4 = (_y5 + y3) / 2;
      } else {
        var d = 1 / ab;
        _x4 = _x5 + (ey * bl - dy * cl) * d;
        _y4 = _y5 + (dx * cl - ex * bl) * d;
      }

      circumcenters[j] = _x4;
      circumcenters[j + 1] = _y4;
    } // Compute exterior cell rays.


    var h = hull[hull.length - 1];
    var p0,
        p1 = h * 4;
    var x0,
        x1 = points[2 * h];
    var y0,
        y1 = points[2 * h + 1];
    vectors.fill(0);

    for (var _i11 = 0; _i11 < hull.length; ++_i11) {
      h = hull[_i11];
      p0 = p1, x0 = x1, y0 = y1;
      p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
      vectors[p0 + 2] = vectors[p1] = y0 - y1;
      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
    }
  };

  _proto4.render = function render(context) {
    var buffer = context == null ? context = new Path() : undefined;
    var _this$delaunay2 = this.delaunay,
        halfedges = _this$delaunay2.halfedges,
        inedges = _this$delaunay2.inedges,
        hull = _this$delaunay2.hull,
        circumcenters = this.circumcenters,
        vectors = this.vectors;
    if (hull.length <= 1) return null;

    for (var i = 0, n = halfedges.length; i < n; ++i) {
      var j = halfedges[i];
      if (j < i) continue;
      var ti = Math.floor(i / 3) * 2;
      var tj = Math.floor(j / 3) * 2;
      var xi = circumcenters[ti];
      var yi = circumcenters[ti + 1];
      var xj = circumcenters[tj];
      var yj = circumcenters[tj + 1];

      this._renderSegment(xi, yi, xj, yj, context);
    }

    var h0,
        h1 = hull[hull.length - 1];

    for (var _i12 = 0; _i12 < hull.length; ++_i12) {
      h0 = h1, h1 = hull[_i12];
      var t = Math.floor(inedges[h1] / 3) * 2;
      var _x6 = circumcenters[t];
      var _y6 = circumcenters[t + 1];
      var v = h0 * 4;

      var p = this._project(_x6, _y6, vectors[v + 2], vectors[v + 3]);

      if (p) this._renderSegment(_x6, _y6, p[0], p[1], context);
    }

    return buffer && buffer.value();
  };

  _proto4.renderBounds = function renderBounds(context) {
    var buffer = context == null ? context = new Path() : undefined;
    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer && buffer.value();
  };

  _proto4.renderCell = function renderCell(i, context) {
    var buffer = context == null ? context = new Path() : undefined;

    var points = this._clip(i);

    if (points === null || !points.length) return;
    context.moveTo(points[0], points[1]);
    var n = points.length;

    while (points[0] === points[n - 2] && points[1] === points[n - 1] && n > 1) {
      n -= 2;
    }

    for (var _i13 = 2; _i13 < n; _i13 += 2) {
      if (points[_i13] !== points[_i13 - 2] || points[_i13 + 1] !== points[_i13 - 1]) context.lineTo(points[_i13], points[_i13 + 1]);
    }

    context.closePath();
    return buffer && buffer.value();
  };

  _proto4.cellPolygons = /*#__PURE__*/runtime_1.mark(function cellPolygons() {
    var points, i, n, cell;
    return runtime_1.wrap(function cellPolygons$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            points = this.delaunay.points;
            i = 0, n = points.length / 2;

          case 2:
            if (!(i < n)) {
              _context.next = 11;
              break;
            }

            cell = this.cellPolygon(i);

            if (!cell) {
              _context.next = 8;
              break;
            }

            cell.index = i;
            _context.next = 8;
            return cell;

          case 8:
            ++i;
            _context.next = 2;
            break;

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, cellPolygons, this);
  });

  _proto4.cellPolygon = function cellPolygon(i) {
    var polygon = new Polygon();
    this.renderCell(i, polygon);
    return polygon.value();
  };

  _proto4._renderSegment = function _renderSegment(x0, y0, x1, y1, context) {
    var S;

    var c0 = this._regioncode(x0, y0);

    var c1 = this._regioncode(x1, y1);

    if (c0 === 0 && c1 === 0) {
      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
    } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
      context.moveTo(S[0], S[1]);
      context.lineTo(S[2], S[3]);
    }
  };

  _proto4.contains = function contains(i, x, y) {
    if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
    return this.delaunay._step(i, x, y) === i;
  };

  _proto4.neighbors = /*#__PURE__*/runtime_1.mark(function neighbors(i) {
    var ci, _iterator, _step, j, cj, ai, li, aj, lj;

    return runtime_1.wrap(function neighbors$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            ci = this._clip(i);

            if (!ci) {
              _context2.next = 23;
              break;
            }

            _iterator = _createForOfIteratorHelperLoose(this.delaunay.neighbors(i));

          case 3:
            if ((_step = _iterator()).done) {
              _context2.next = 23;
              break;
            }

            j = _step.value;
            cj = this._clip(j); // find the common edge

            if (!cj) {
              _context2.next = 21;
              break;
            }

            ai = 0, li = ci.length;

          case 8:
            if (!(ai < li)) {
              _context2.next = 21;
              break;
            }

            aj = 0, lj = cj.length;

          case 10:
            if (!(aj < lj)) {
              _context2.next = 18;
              break;
            }

            if (!(ci[ai] == cj[aj] && ci[ai + 1] == cj[aj + 1] && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj])) {
              _context2.next = 15;
              break;
            }

            _context2.next = 14;
            return j;

          case 14:
            return _context2.abrupt("break", 21);

          case 15:
            aj += 2;
            _context2.next = 10;
            break;

          case 18:
            ai += 2;
            _context2.next = 8;
            break;

          case 21:
            _context2.next = 3;
            break;

          case 23:
          case "end":
            return _context2.stop();
        }
      }
    }, neighbors, this);
  });

  _proto4._cell = function _cell(i) {
    var circumcenters = this.circumcenters,
        _this$delaunay3 = this.delaunay,
        inedges = _this$delaunay3.inedges,
        halfedges = _this$delaunay3.halfedges,
        triangles = _this$delaunay3.triangles;
    var e0 = inedges[i];
    if (e0 === -1) return null; // coincident point

    var points = [];
    var e = e0;

    do {
      var t = Math.floor(e / 3);
      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break; // bad triangulation

      e = halfedges[e];
    } while (e !== e0 && e !== -1);

    return points;
  };

  _proto4._clip = function _clip(i) {
    // degenerate case (1 valid point: return the box)
    if (i === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }

    var points = this._cell(i);

    if (points === null) return null;
    var V = this.vectors;
    var v = i * 4;
    return V[v] || V[v + 1] ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3]) : this._clipFinite(i, points);
  };

  _proto4._clipFinite = function _clipFinite(i, points) {
    var n = points.length;
    var P = null;
    var x0,
        y0,
        x1 = points[n - 2],
        y1 = points[n - 1];

    var c0,
        c1 = this._regioncode(x1, y1);

    var e0, e1;

    for (var j = 0; j < n; j += 2) {
      x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
      c0 = c1, c1 = this._regioncode(x1, y1);

      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P) P.push(x1, y1);else P = [x1, y1];
      } else {
        var S = void 0,
            sx0 = void 0,
            sy0 = void 0,
            sx1 = void 0,
            sy1 = void 0;

        if (c0 === 0) {
          if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
          var _S = S;
          sx0 = _S[0];
          sy0 = _S[1];
          sx1 = _S[2];
          sy1 = _S[3];
        } else {
          if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
          var _S2 = S;
          sx1 = _S2[0];
          sy1 = _S2[1];
          sx0 = _S2[2];
          sy0 = _S2[3];
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
          if (P) P.push(sx0, sy0);else P = [sx0, sy0];
        }

        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        if (P) P.push(sx1, sy1);else P = [sx1, sy1];
      }
    }

    if (P) {
      e0 = e1, e1 = this._edgecode(P[0], P[1]);
      if (e0 && e1) this._edge(i, e0, e1, P, P.length);
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }

    return P;
  };

  _proto4._clipSegment = function _clipSegment(x0, y0, x1, y1, c0, c1) {
    while (true) {
      if (c0 === 0 && c1 === 0) return [x0, y0, x1, y1];
      if (c0 & c1) return null;

      var _x7 = void 0,
          _y7 = void 0,
          c = c0 || c1;

      if (c & 8) _x7 = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), _y7 = this.ymax;else if (c & 4) _x7 = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), _y7 = this.ymin;else if (c & 2) _y7 = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), _x7 = this.xmax;else _y7 = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), _x7 = this.xmin;
      if (c0) x0 = _x7, y0 = _y7, c0 = this._regioncode(x0, y0);else x1 = _x7, y1 = _y7, c1 = this._regioncode(x1, y1);
    }
  };

  _proto4._clipInfinite = function _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
    var P = Array.from(points),
        p;
    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);

    if (P = this._clipFinite(i, P)) {
      for (var j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
      }
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }

    return P;
  };

  _proto4._edge = function _edge(i, e0, e1, P, j) {
    while (e0 !== e1) {
      var _x8 = void 0,
          _y8 = void 0;

      switch (e0) {
        case 5:
          e0 = 4;
          continue;
        // top-left

        case 4:
          e0 = 6, _x8 = this.xmax, _y8 = this.ymin;
          break;
        // top

        case 6:
          e0 = 2;
          continue;
        // top-right

        case 2:
          e0 = 10, _x8 = this.xmax, _y8 = this.ymax;
          break;
        // right

        case 10:
          e0 = 8;
          continue;
        // bottom-right

        case 8:
          e0 = 9, _x8 = this.xmin, _y8 = this.ymax;
          break;
        // bottom

        case 9:
          e0 = 1;
          continue;
        // bottom-left

        case 1:
          e0 = 5, _x8 = this.xmin, _y8 = this.ymin;
          break;
        // left
      }

      if ((P[j] !== _x8 || P[j + 1] !== _y8) && this.contains(i, _x8, _y8)) {
        P.splice(j, 0, _x8, _y8), j += 2;
      }
    }

    if (P.length > 4) {
      for (var _i14 = 0; _i14 < P.length; _i14 += 2) {
        var _j3 = (_i14 + 2) % P.length,
            k = (_i14 + 4) % P.length;

        if (P[_i14] === P[_j3] && P[_j3] === P[k] || P[_i14 + 1] === P[_j3 + 1] && P[_j3 + 1] === P[k + 1]) P.splice(_j3, 2), _i14 -= 2;
      }
    }

    return j;
  };

  _proto4._project = function _project(x0, y0, vx, vy) {
    var t = Infinity,
        c,
        x,
        y;

    if (vy < 0) {
      // top
      if (y0 <= this.ymin) return null;
      if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
    } else if (vy > 0) {
      // bottom
      if (y0 >= this.ymax) return null;
      if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
    }

    if (vx > 0) {
      // right
      if (x0 >= this.xmax) return null;
      if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
    } else if (vx < 0) {
      // left
      if (x0 <= this.xmin) return null;
      if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
    }

    return [x, y];
  };

  _proto4._edgecode = function _edgecode(x, y) {
    return (x === this.xmin ? 1 : x === this.xmax ? 2 : 0) | (y === this.ymin ? 4 : y === this.ymax ? 8 : 0);
  };

  _proto4._regioncode = function _regioncode(x, y) {
    return (x < this.xmin ? 1 : x > this.xmax ? 2 : 0) | (y < this.ymin ? 4 : y > this.ymax ? 8 : 0);
  };

  return Voronoi;
}();

var tau = 2 * Math.PI,
    pow = Math.pow;

function pointX(p) {
  return p[0];
}

function pointY(p) {
  return p[1];
} // A triangulation is collinear if all its triangles have a non-null area


function collinear(d) {
  var triangles = d.triangles,
      coords = d.coords;

  for (var i = 0; i < triangles.length; i += 3) {
    var a = 2 * triangles[i],
        b = 2 * triangles[i + 1],
        c = 2 * triangles[i + 2],
        cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1]) - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);
    if (cross > 1e-10) return false;
  }

  return true;
}

function jitter(x, y, r) {
  return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
}

var Delaunay = /*#__PURE__*/function () {
  Delaunay.from = function from(points, fx, fy, that) {
    if (fx === void 0) {
      fx = pointX;
    }

    if (fy === void 0) {
      fy = pointY;
    }

    return new Delaunay("length" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));
  };

  function Delaunay(points) {
    this._delaunator = new Delaunator(points);
    this.inedges = new Int32Array(points.length / 2);
    this._hullIndex = new Int32Array(points.length / 2);
    this.points = this._delaunator.coords;

    this._init();
  }

  var _proto5 = Delaunay.prototype;

  _proto5.update = function update() {
    this._delaunator.update();

    this._init();

    return this;
  };

  _proto5._init = function _init() {
    var d = this._delaunator,
        points = this.points; // check for collinear

    if (d.hull && d.hull.length > 2 && collinear(d)) {
      this.collinear = Int32Array.from({
        length: points.length / 2
      }, function (_, i) {
        return i;
      }).sort(function (i, j) {
        return points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1];
      }); // for exact neighbors

      var e = this.collinear[0],
          f = this.collinear[this.collinear.length - 1],
          bounds = [points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1]],
          r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);

      for (var i = 0, n = points.length / 2; i < n; ++i) {
        var p = jitter(points[2 * i], points[2 * i + 1], r);
        points[2 * i] = p[0];
        points[2 * i + 1] = p[1];
      }

      this._delaunator = new Delaunator(points);
    } else {
      delete this.collinear;
    }

    var halfedges = this.halfedges = this._delaunator.halfedges;
    var hull = this.hull = this._delaunator.hull;
    var triangles = this.triangles = this._delaunator.triangles;
    var inedges = this.inedges.fill(-1);

    var hullIndex = this._hullIndex.fill(-1); // Compute an index from each point to an (arbitrary) incoming halfedge
    // Used to give the first neighbor of each point; for this reason,
    // on the hull we give priority to exterior halfedges


    for (var _e2 = 0, _n2 = halfedges.length; _e2 < _n2; ++_e2) {
      var _p = triangles[_e2 % 3 === 2 ? _e2 - 2 : _e2 + 1];
      if (halfedges[_e2] === -1 || inedges[_p] === -1) inedges[_p] = _e2;
    }

    for (var _i15 = 0, _n3 = hull.length; _i15 < _n3; ++_i15) {
      hullIndex[hull[_i15]] = _i15;
    } // degenerate case: 1 or 2 (distinct) points


    if (hull.length <= 2 && hull.length > 0) {
      this.triangles = new Int32Array(3).fill(-1);
      this.halfedges = new Int32Array(3).fill(-1);
      this.triangles[0] = hull[0];
      this.triangles[1] = hull[1];
      this.triangles[2] = hull[1];
      inedges[hull[0]] = 1;
      if (hull.length === 2) inedges[hull[1]] = 0;
    }
  };

  _proto5.voronoi = function voronoi(bounds) {
    return new Voronoi(this, bounds);
  };

  _proto5.neighbors = /*#__PURE__*/runtime_1.mark(function neighbors(i) {
    var inedges, hull, _hullIndex, halfedges, triangles, collinear, l, e0, e, p0, p;

    return runtime_1.wrap(function neighbors$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            inedges = this.inedges, hull = this.hull, _hullIndex = this._hullIndex, halfedges = this.halfedges, triangles = this.triangles, collinear = this.collinear; // degenerate case with several collinear points

            if (!collinear) {
              _context3.next = 10;
              break;
            }

            l = collinear.indexOf(i);

            if (!(l > 0)) {
              _context3.next = 6;
              break;
            }

            _context3.next = 6;
            return collinear[l - 1];

          case 6:
            if (!(l < collinear.length - 1)) {
              _context3.next = 9;
              break;
            }

            _context3.next = 9;
            return collinear[l + 1];

          case 9:
            return _context3.abrupt("return");

          case 10:
            e0 = inedges[i];

            if (!(e0 === -1)) {
              _context3.next = 13;
              break;
            }

            return _context3.abrupt("return");

          case 13:
            // coincident point
            e = e0, p0 = -1;

          case 14:
            _context3.next = 16;
            return p0 = triangles[e];

          case 16:
            e = e % 3 === 2 ? e - 2 : e + 1;

            if (!(triangles[e] !== i)) {
              _context3.next = 19;
              break;
            }

            return _context3.abrupt("return");

          case 19:
            // bad triangulation
            e = halfedges[e];

            if (!(e === -1)) {
              _context3.next = 26;
              break;
            }

            p = hull[(_hullIndex[i] + 1) % hull.length];

            if (!(p !== p0)) {
              _context3.next = 25;
              break;
            }

            _context3.next = 25;
            return p;

          case 25:
            return _context3.abrupt("return");

          case 26:
            if (e !== e0) {
              _context3.next = 14;
              break;
            }

          case 27:
          case "end":
            return _context3.stop();
        }
      }
    }, neighbors, this);
  });

  _proto5.find = function find(x, y, i) {
    if (i === void 0) {
      i = 0;
    }

    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
    var i0 = i;
    var c;

    while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) {
      i = c;
    }

    return c;
  };

  _proto5._step = function _step(i, x, y) {
    var inedges = this.inedges,
        hull = this.hull,
        _hullIndex = this._hullIndex,
        halfedges = this.halfedges,
        triangles = this.triangles,
        points = this.points;
    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
    var c = i;
    var dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);
    var e0 = inedges[i];
    var e = e0;

    do {
      var t = triangles[e];
      var dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);
      if (dt < dc) dc = dt, c = t;
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break; // bad triangulation

      e = halfedges[e];

      if (e === -1) {
        e = hull[(_hullIndex[i] + 1) % hull.length];

        if (e !== t) {
          if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;
        }

        break;
      }
    } while (e !== e0);

    return c;
  };

  _proto5.render = function render(context) {
    var buffer = context == null ? context = new Path() : undefined;
    var points = this.points,
        halfedges = this.halfedges,
        triangles = this.triangles;

    for (var i = 0, n = halfedges.length; i < n; ++i) {
      var j = halfedges[i];
      if (j < i) continue;
      var ti = triangles[i] * 2;
      var tj = triangles[j] * 2;
      context.moveTo(points[ti], points[ti + 1]);
      context.lineTo(points[tj], points[tj + 1]);
    }

    this.renderHull(context);
    return buffer && buffer.value();
  };

  _proto5.renderPoints = function renderPoints(context, r) {
    if (r === void 0) {
      r = 2;
    }

    var buffer = context == null ? context = new Path() : undefined;
    var points = this.points;

    for (var i = 0, n = points.length; i < n; i += 2) {
      var _x9 = points[i],
          _y9 = points[i + 1];
      context.moveTo(_x9 + r, _y9);
      context.arc(_x9, _y9, r, 0, tau);
    }

    return buffer && buffer.value();
  };

  _proto5.renderHull = function renderHull(context) {
    var buffer = context == null ? context = new Path() : undefined;
    var hull = this.hull,
        points = this.points;
    var h = hull[0] * 2,
        n = hull.length;
    context.moveTo(points[h], points[h + 1]);

    for (var i = 1; i < n; ++i) {
      var _h = 2 * hull[i];

      context.lineTo(points[_h], points[_h + 1]);
    }

    context.closePath();
    return buffer && buffer.value();
  };

  _proto5.hullPolygon = function hullPolygon() {
    var polygon = new Polygon();
    this.renderHull(polygon);
    return polygon.value();
  };

  _proto5.renderTriangle = function renderTriangle(i, context) {
    var buffer = context == null ? context = new Path() : undefined;
    var points = this.points,
        triangles = this.triangles;
    var t0 = triangles[i *= 3] * 2;
    var t1 = triangles[i + 1] * 2;
    var t2 = triangles[i + 2] * 2;
    context.moveTo(points[t0], points[t0 + 1]);
    context.lineTo(points[t1], points[t1 + 1]);
    context.lineTo(points[t2], points[t2 + 1]);
    context.closePath();
    return buffer && buffer.value();
  };

  _proto5.trianglePolygons = /*#__PURE__*/runtime_1.mark(function trianglePolygons() {
    var triangles, i, n;
    return runtime_1.wrap(function trianglePolygons$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            triangles = this.triangles;
            i = 0, n = triangles.length / 3;

          case 2:
            if (!(i < n)) {
              _context4.next = 8;
              break;
            }

            _context4.next = 5;
            return this.trianglePolygon(i);

          case 5:
            ++i;
            _context4.next = 2;
            break;

          case 8:
          case "end":
            return _context4.stop();
        }
      }
    }, trianglePolygons, this);
  });

  _proto5.trianglePolygon = function trianglePolygon(i) {
    var polygon = new Polygon();
    this.renderTriangle(i, polygon);
    return polygon.value();
  };

  return Delaunay;
}();

function flatArray(points, fx, fy, that) {
  var n = points.length;
  var array = new Float64Array(n * 2);

  for (var i = 0; i < n; ++i) {
    var p = points[i];
    array[i * 2] = fx.call(that, p, i, points);
    array[i * 2 + 1] = fy.call(that, p, i, points);
  }

  return array;
}

function flatIterable(points, fx, fy, that) {
  var i, _iterator2, _step2, p;

  return runtime_1.wrap(function flatIterable$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          i = 0;
          _iterator2 = _createForOfIteratorHelperLoose(points);

        case 2:
          if ((_step2 = _iterator2()).done) {
            _context5.next = 11;
            break;
          }

          p = _step2.value;
          _context5.next = 6;
          return fx.call(that, p, i, points);

        case 6:
          _context5.next = 8;
          return fy.call(that, p, i, points);

        case 8:
          ++i;

        case 9:
          _context5.next = 2;
          break;

        case 11:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked);
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector(f) {
  var delta = f;
  var compare = f;

  if (f.length === 1) {
    delta = function delta(d, x) {
      return f(d) - x;
    };

    compare = ascendingComparator(f);
  }

  function left(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;

    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
    }

    return lo;
  }

  function right(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;

    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
    }

    return lo;
  }

  function center(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    var i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {
    left: left,
    center: center,
    right: right
  };
}

function ascendingComparator(f) {
  return function (d, x) {
    return ascending(f(d), x);
  };
}

function number(x) {
  return x === null ? NaN : +x;
}

var ascendingBisect = /*#__PURE__*/bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectCenter = /*#__PURE__*/bisector(number).center;
var e10 = /*#__PURE__*/Math.sqrt(50),
    e5 = /*#__PURE__*/Math.sqrt(10),
    e2 = /*#__PURE__*/Math.sqrt(2);

function ticks(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;
  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    var r0 = Math.round(start / step),
        r1 = Math.round(stop / step);
    if (r0 * step < start) ++r0;
    if (r1 * step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);

    while (++i < n) {
      ticks[i] = (r0 + i) * step;
    }
  } else {
    step = -step;

    var _r = Math.round(start * step),
        _r2 = Math.round(stop * step);

    if (_r / step < start) ++_r;
    if (_r2 / step > stop) --_r2;
    ticks = new Array(n = _r2 - _r + 1);

    while (++i < n) {
      ticks[i] = (_r + i) / step;
    }
  }

  if (reverse) ticks.reverse();
  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;else if (error >= e5) step1 *= 5;else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

function sequence(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

function initRange(domain, range) {
  switch (arguments.length) {
    case 0:
      break;

    case 1:
      this.range(domain);
      break;

    default:
      this.range(range).domain(domain);
      break;
  }

  return this;
}

var implicit = /*#__PURE__*/Symbol("implicit");

function ordinal() {
  var index = new Map(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    var key = d + "",
        i = index.get(key);

    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }

    return range[(i - 1) % range.length];
  }

  scale.domain = function (_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = new Map();

    for (var _iterator3 = _createForOfIteratorHelperLoose(_), _step3; !(_step3 = _iterator3()).done;) {
      var value = _step3.value;
      var key = value + "";
      if (index.has(key)) continue;
      index.set(key, domain.push(value));
    }

    return scale;
  };

  scale.range = function (_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };

  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function () {
    return ordinal(domain, range).unknown(unknown);
  };

  initRange.apply(scale, arguments);
  return scale;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      r0 = 0,
      r1 = 1,
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;
  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = r1 < r0,
        start = reverse ? r1 : r0,
        stop = reverse ? r0 : r1;
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = sequence(n).map(function (i) {
      return start + step * i;
    });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function (_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function (_) {
    var _ref2;

    return arguments.length ? ((_ref2 = _, r0 = _ref2[0], r1 = _ref2[1], _ref2), r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };

  scale.rangeRound = function (_) {
    var _ref3;

    return (_ref3 = _, r0 = _ref3[0], r1 = _ref3[1], _ref3), r0 = +r0, r1 = +r1, round = true, rescale();
  };

  scale.bandwidth = function () {
    return bandwidth;
  };

  scale.step = function () {
    return step;
  };

  scale.round = function (_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function (_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function (_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function (_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function (_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function () {
    return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };

  return initRange.apply(rescale(), arguments);
}

function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);

  for (var key in definition) {
    prototype[key] = definition[key];
  }

  return prototype;
}

function Color() {}

var _darker = 0.7;

var _brighter = 1 / _darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = /*#__PURE__*/new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = /*#__PURE__*/new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = /*#__PURE__*/new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = /*#__PURE__*/new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = /*#__PURE__*/new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = /*#__PURE__*/new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};
define(Color, color, {
  copy: function copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
  : l === 3 ? new Rgb(m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
  : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
  : l === 4 ? rgba(m >> 12 & 0xf | m >> 8 & 0xf0, m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, ((m & 0xf) << 4 | m & 0xf) / 0xff) // #f000
  : null // invalid hex
  ) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
  : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
  : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
  : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
  : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
  : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
  : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
  : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function rgb() {
    return this;
  },
  displayable: function displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity;
  a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;

  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }

  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
  },
  displayable: function displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl: function formatHsl() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
  }
}));
/* From FvD 13.37, CSS Color Module Level 3 */

function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

var constant = function constant(x) {
  return function () {
    return x;
  };
};

function linear(a, d) {
  return function (t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
    return Math.pow(a + t * b, y);
  };
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function (a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant(isNaN(a) ? b : a);
}

var rgb$1 = /*#__PURE__*/function rgbGamma(y) {
  var color = /*#__PURE__*/gamma(y);

  function rgb$1(start, end) {
    var r = color((start = rgb(start)).r, (end = rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function (t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb$1.gamma = rgbGamma;
  return rgb$1;
}(1);

function numberArray(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function (t) {
    for (i = 0; i < n; ++i) {
      c[i] = a[i] * (1 - t) + b[i] * t;
    }

    return c;
  };
}

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) {
    x[i] = interpolate(a[i], b[i]);
  }

  for (; i < nb; ++i) {
    c[i] = b[i];
  }

  return function (t) {
    for (i = 0; i < na; ++i) {
      c[i] = x[i](t);
    }

    return c;
  };
}

function date(a, b) {
  var d = new Date();
  return a = +a, b = +b, function (t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

function interpolateNumber(a, b) {
  return a = +a, b = +b, function (t) {
    return a * (1 - t) + b * t;
  };
}

function object(a, b) {
  var i = {},
      c = {},
      k;
  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = interpolate(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function (t) {
    for (k in i) {
      c[k] = i[k](t);
    }

    return c;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = /*#__PURE__*/new RegExp(reA.source, "g");

function zero(b) {
  return function () {
    return b;
  };
}

function one(b) {
  return function (t) {
    return b(t) + "";
  };
}

function string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0,
      // scan index for next number in b
  am,
      // current match in a
  bm,
      // current match in b
  bs,
      // string preceding current number in b, if any
  i = -1,
      // index in s
  s = [],
      // string constants and placeholders
  q = []; // number interpolators
  // Coerce inputs to strings.

  a = a + "", b = b + ""; // Interpolate pairs of numbers in a & b.

  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }

    if ((am = am[0]) === (bm = bm[0])) {
      // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else {
      // interpolate non-matching numbers
      s[++i] = null;
      q.push({
        i: i,
        x: interpolateNumber(am, bm)
      });
    }

    bi = reB.lastIndex;
  } // Add remains of b.


  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  } // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.


  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
    for (var i = 0, o; i < b; ++i) {
      s[(o = q[i]).i] = o.x(t);
    }

    return s.join("");
  });
}

function interpolate(a, b) {
  var t = typeof b,
      c;
  return b == null || t === "boolean" ? constant(b) : (t === "number" ? interpolateNumber : t === "string" ? (c = color(b)) ? (b = c, rgb$1) : string : b instanceof color ? rgb$1 : b instanceof Date ? date : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber)(a, b);
}

function interpolateRound(a, b) {
  return a = +a, b = +b, function (t) {
    return Math.round(a * (1 - t) + b * t);
  };
}

function constants(x) {
  return function () {
    return x;
  };
}

function number$1(x) {
  return +x;
}

var unit = [0, 1];

function identity$1(x) {
  return x;
}

function normalize(a, b) {
  return (b -= a = +a) ? function (x) {
    return (x - a) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}

function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function (x) {
    return Math.max(a, Math.min(b, x));
  };
} // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].


function bimap(domain, range, interpolate) {
  var d0 = domain[0],
      d1 = domain[1],
      r0 = range[0],
      r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function (x) {
    return r0(d0(x));
  };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1; // Reverse descending domains.

  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function (x) {
    var i = bisectRight(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate$1 = interpolate,
      transform,
      untransform,
      unknown,
      clamp = identity$1,
      piecewise,
      output,
      input;

  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity$1) clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate$1)))(transform(clamp(x)));
  }

  scale.invert = function (y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
  };

  scale.domain = function (_) {
    return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
  };

  scale.range = function (_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.rangeRound = function (_) {
    return range = Array.from(_), interpolate$1 = interpolateRound, rescale();
  };

  scale.clamp = function (_) {
    return arguments.length ? (clamp = _ ? true : identity$1, rescale()) : clamp !== identity$1;
  };

  scale.interpolate = function (_) {
    return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
  };

  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function (t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous() {
  return transformer()(identity$1, identity$1);
}

function formatDecimal(x) {
  return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
} // Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].


function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity

  var i,
      coefficient = x.slice(0, i); // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).

  return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x.slice(i + 1)];
}

function exponent(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}

function formatGroup(grouping, thousands) {
  return function (value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

function formatNumerals(numerals) {
  return function (value) {
    return value.replace(/[0-9]/g, function (i) {
      return numerals[+i];
    });
  };
} // [[fill]align][sign][symbol][0][width][,][.precision][~][type]


var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function () {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === undefined ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
}; // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.


function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".":
        i0 = i1 = i;
        break;

      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;

      default:
        if (!+s[i]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }

  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

var prefixExponent;

function formatPrefixAuto(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

function formatRounded(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

var formatTypes = {
  "%": function _(x, p) {
    return (x * 100).toFixed(p);
  },
  "b": function b(x) {
    return Math.round(x).toString(2);
  },
  "c": function c(x) {
    return x + "";
  },
  "d": formatDecimal,
  "e": function e(x, p) {
    return x.toExponential(p);
  },
  "f": function f(x, p) {
    return x.toFixed(p);
  },
  "g": function g(x, p) {
    return x.toPrecision(p);
  },
  "o": function o(x) {
    return Math.round(x).toString(8);
  },
  "p": function p(x, _p2) {
    return formatRounded(x * 100, _p2);
  },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function X(x) {
    return Math.round(x).toString(16).toUpperCase();
  },
  "x": function x(_x10) {
    return Math.round(_x10).toString(16);
  }
};

function identity$1$1(x) {
  return x;
}

var map = Array.prototype.map,
    prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];

function formatLocale(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? identity$1$1 : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? identity$1$1 : formatNumerals(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type; // The "n" type is an alias for ",g".

    if (type === "n") comma = true, type = "g"; // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g"; // If zero fill is specified, padding goes after sign and before digits.

    if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "="; // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.

    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : ""; // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?

    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type); // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].

    precision = precision === undefined ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i,
          n,
          c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value; // Determine the sign. -0 is not less than 0, but 1 / -0 is!

        var valueNegative = value < 0 || 1 / value < 0; // Perform the initial formatting.

        value = isNaN(value) ? nan : formatType(Math.abs(value), precision); // Trim insignificant zeros.

        if (trim) value = formatTrim(value); // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.

        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false; // Compute the prefix and suffix.

        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : ""); // Break the formatted value into the integer value part that can be
        // grouped, and fractional or exponential suffix part that is not.

        if (maybeSuffix) {
          i = -1, n = value.length;

          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      } // If the fill character is not "0", grouping is applied before padding.


      if (comma && !zero) value = group(value, Infinity); // Compute the padding.

      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : ""; // If the fill character is "0", grouping is applied after padding.

      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = ""; // Reconstruct the final output based on the desired alignment.

      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;

        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;

        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;

        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }

      return numerals(value);
    }

    format.toString = function () {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function (value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}

function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}

function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
}

function tickFormat(start, stop, count, specifier) {
  var step = tickStep(start, stop, count),
      precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);

  switch (specifier.type) {
    case "s":
      {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
        return formatPrefix(specifier, value);
      }

    case "":
    case "e":
    case "g":
    case "p":
    case "r":
      {
        if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }

    case "f":
    case "%":
      {
        if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
  }

  return format(specifier);
}

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function (count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function (count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function (count) {
    if (count == null) count = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count);

      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }

      prestep = step;
    }

    return scale;
  };

  return scale;
}

function linear$1() {
  var scale = continuous();

  scale.copy = function () {
    return copy(scale, linear$1());
  };

  initRange.apply(scale, arguments);
  return linearish(scale);
}

function nice(domain, interval) {
  domain = domain.slice();
  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

function transformLog(x) {
  return Math.log(x);
}

function transformExp(x) {
  return Math.exp(x);
}

function transformLogn(x) {
  return -Math.log(-x);
}

function transformExpn(x) {
  return -Math.exp(-x);
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {
    return Math.pow(base, x);
  };
}

function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), function (x) {
    return Math.log(x) / base;
  });
}

function reflect(f) {
  return function (x) {
    return -f(-x);
  };
}

function loggish(transform) {
  var scale = transform(transformLog, transformExp),
      domain = scale.domain,
      base = 10,
      logs,
      pows;

  function rescale() {
    logs = logp(base), pows = powp(base);

    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }

    return scale;
  }

  scale.base = function (_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function (_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function (count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;
    if (r = v < u) i = u, u = v, v = i;
    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0) for (; i <= j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i <= j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = ticks(u, v, n);
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function (count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = format(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?

    return function (d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function () {
    return domain(nice(domain(), {
      floor: function floor(x) {
        return pows(Math.floor(logs(x)));
      },
      ceil: function ceil(x) {
        return pows(Math.ceil(logs(x)));
      }
    }));
  };

  return scale;
}

function log() {
  var scale = loggish(transformer()).domain([1, 10]);

  scale.copy = function () {
    return copy(scale, log()).base(scale.base());
  };

  initRange.apply(scale, arguments);
  return scale;
}

var t0 = /*#__PURE__*/new Date(),
    t1 = /*#__PURE__*/new Date();

function newInterval(floori, offseti, count, field) {
  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date() : new Date(+date)), date;
  }

  interval.floor = function (date) {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = function (date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function (date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function (date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function (start, stop, step) {
    var range = [],
        previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date

    do {
      range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    } while (previous < start && start < stop);

    return range;
  };

  interval.filter = function (test) {
    return newInterval(function (date) {
      if (date >= date) while (floori(date), !test(date)) {
        date.setTime(date - 1);
      }
    }, function (date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty

        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty

        }
      }
    });
  };

  if (count) {
    interval.count = function (start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function (step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function (d) {
        return field(d) % step === 0;
      } : function (d) {
        return interval.count(0, d) % step === 0;
      });
    };
  }

  return interval;
}

var millisecond = /*#__PURE__*/newInterval(function () {// noop
}, function (date, step) {
  date.setTime(+date + step);
}, function (start, end) {
  return end - start;
}); // An optimized implementation for this simple case.

millisecond.every = function (k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function (date) {
    date.setTime(Math.floor(date / k) * k);
  }, function (date, step) {
    date.setTime(+date + step * k);
  }, function (start, end) {
    return (end - start) / k;
  });
};
var durationSecond = 1000;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;
var second = /*#__PURE__*/newInterval(function (date) {
  date.setTime(date - date.getMilliseconds());
}, function (date, step) {
  date.setTime(+date + step * durationSecond);
}, function (start, end) {
  return (end - start) / durationSecond;
}, function (date) {
  return date.getUTCSeconds();
});
var minute = /*#__PURE__*/newInterval(function (date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, function (date, step) {
  date.setTime(+date + step * durationMinute);
}, function (start, end) {
  return (end - start) / durationMinute;
}, function (date) {
  return date.getMinutes();
});
var hour = /*#__PURE__*/newInterval(function (date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, function (date, step) {
  date.setTime(+date + step * durationHour);
}, function (start, end) {
  return (end - start) / durationHour;
}, function (date) {
  return date.getHours();
});
var day = /*#__PURE__*/newInterval(function (date) {
  return date.setHours(0, 0, 0, 0);
}, function (date, step) {
  return date.setDate(date.getDate() + step);
}, function (start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function (date) {
  return date.getDate() - 1;
});

function weekday(i) {
  return newInterval(function (date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function (start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = /*#__PURE__*/weekday(0);
var monday = /*#__PURE__*/weekday(1);
var thursday = /*#__PURE__*/weekday(4);
var month = /*#__PURE__*/newInterval(function (date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function (date, step) {
  date.setMonth(date.getMonth() + step);
}, function (start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function (date) {
  return date.getMonth();
});
var year = /*#__PURE__*/newInterval(function (date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function (date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function (start, end) {
  return end.getFullYear() - start.getFullYear();
}, function (date) {
  return date.getFullYear();
}); // An optimized implementation for this simple case.

year.every = function (k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};
var utcMinute = /*#__PURE__*/newInterval(function (date) {
  date.setUTCSeconds(0, 0);
}, function (date, step) {
  date.setTime(+date + step * durationMinute);
}, function (start, end) {
  return (end - start) / durationMinute;
}, function (date) {
  return date.getUTCMinutes();
});
var utcHour = /*#__PURE__*/newInterval(function (date) {
  date.setUTCMinutes(0, 0, 0);
}, function (date, step) {
  date.setTime(+date + step * durationHour);
}, function (start, end) {
  return (end - start) / durationHour;
}, function (date) {
  return date.getUTCHours();
});
var utcDay = /*#__PURE__*/newInterval(function (date) {
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function (start, end) {
  return (end - start) / durationDay;
}, function (date) {
  return date.getUTCDate() - 1;
});

function utcWeekday(i) {
  return newInterval(function (date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function (start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = /*#__PURE__*/utcWeekday(0);
var utcMonday = /*#__PURE__*/utcWeekday(1);
var utcThursday = /*#__PURE__*/utcWeekday(4);
var utcMonth = /*#__PURE__*/newInterval(function (date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function (start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function (date) {
  return date.getUTCMonth();
});
var utcYear = /*#__PURE__*/newInterval(function (date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function (start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function (date) {
  return date.getUTCFullYear();
}); // An optimized implementation for this simple case.

utcYear.every = function (k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

function ticker(year, month, week, day, hour, minute) {
  var tickIntervals = [[second, 1, durationSecond], [second, 5, 5 * durationSecond], [second, 15, 15 * durationSecond], [second, 30, 30 * durationSecond], [minute, 1, durationMinute], [minute, 5, 5 * durationMinute], [minute, 15, 15 * durationMinute], [minute, 30, 30 * durationMinute], [hour, 1, durationHour], [hour, 3, 3 * durationHour], [hour, 6, 6 * durationHour], [hour, 12, 12 * durationHour], [day, 1, durationDay], [day, 2, 2 * durationDay], [week, 1, durationWeek], [month, 1, durationMonth], [month, 3, 3 * durationMonth], [year, 1, durationYear]];

  function ticks(start, stop, count) {
    var reverse = stop < start;

    if (reverse) {
      var _ref4 = [stop, start];
      start = _ref4[0];
      stop = _ref4[1];
    }

    var interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
    var ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop

    return reverse ? ticks.reverse() : ticks;
  }

  function tickInterval(start, stop, count) {
    var target = Math.abs(stop - start) / count;
    var i = bisector(function (_ref5) {
      var step = _ref5[2];
      return step;
    }).right(tickIntervals, target);
    if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
    if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count), 1));
    var _tickIntervals = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i],
        t = _tickIntervals[0],
        step = _tickIntervals[1];
    return t.every(step);
  }

  return [ticks, tickInterval];
}

var _ticker = /*#__PURE__*/ticker(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute),
    utcTicks = _ticker[0],
    utcTickInterval = _ticker[1];

var _ticker2 = /*#__PURE__*/ticker(year, month, sunday, day, hour, minute),
    timeTicks = _ticker2[0],
    timeTickInterval = _ticker2[1];

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }

  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }

  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {
    y: y,
    m: m,
    d: d,
    H: 0,
    M: 0,
    S: 0,
    L: 0
  };
}

function formatLocale$1(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;
  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  }; // These recursive directive definitions must be deferred.

  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function (date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;
      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function (string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week,
          day$1;
      if (i != string.length) return null; // If a UNIX timestamp is specified, return it.

      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0)); // If this is utcParse, never use the local timezone.

      if (Z && !("Z" in d)) d.Z = 0; // The am-pm flag is 0 for AM, and 1 for PM.

      if ("p" in d) d.H = d.H % 12 + d.p * 12; // If the month was not specified, inherit from the quarter.

      if (d.m === undefined) d.m = "q" in d ? d.q : 0; // Convert day-of-week and week-of-year to day-of-year.

      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;

        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day$1 = week.getUTCDay();
          week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day$1 = week.getDay();
          week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
          week = day.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day$1 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
      } // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.


      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      } // Otherwise, all fields are in local time.


      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);

      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || (j = parse(d, string, j)) < 0) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function format(specifier) {
      var f = newFormat(specifier += "", formats);

      f.toString = function () {
        return specifier;
      };

      return f;
    },
    parse: function parse(specifier) {
      var p = newParse(specifier += "", false);

      p.toString = function () {
        return specifier;
      };

      return p;
    },
    utcFormat: function utcFormat(specifier) {
      var f = newFormat(specifier += "", utcFormats);

      f.toString = function () {
        return specifier;
      };

      return f;
    },
    utcParse: function utcParse(specifier) {
      var p = newParse(specifier += "", true);

      p.toString = function () {
        return specifier;
      };

      return p;
    }
  };
}

var pads = {
  "-": "",
  "_": " ",
  "0": "0"
},
    numberRe = /^\s*\d+/,
    // note: ignores next directive
percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  return new Map(names.map(function (name, i) {
    return [name.toLowerCase(), i];
  }));
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + day.count(year(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(year(d) - 1, d), p, 2);
}

function dISO(d) {
  var day = d.getDay();
  return day >= 4 || day === 0 ? thursday(d) : thursday.ceil(d);
}

function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(monday.count(year(d) - 1, d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = day >= 4 || day === 0 ? thursday(d) : thursday.ceil(d);
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
}

function UTCdISO(d) {
  var day = d.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
}

function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale$1;
var timeFormat;
var utcFormat;
defaultLocale$1({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale$1(definition) {
  locale$1 = formatLocale$1(definition);
  timeFormat = locale$1.format;
  utcFormat = locale$1.utcFormat;
  return locale$1;
}

function date$1(t) {
  return new Date(t);
}

function number$2(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
  var scale = continuous(),
      invert = scale.invert,
      domain = scale.domain;
  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond : minute(date) < date ? formatSecond : hour(date) < date ? formatMinute : day(date) < date ? formatHour : month(date) < date ? week(date) < date ? formatDay : formatWeek : year(date) < date ? formatMonth : formatYear)(date);
  }

  scale.invert = function (y) {
    return new Date(invert(y));
  };

  scale.domain = function (_) {
    return arguments.length ? domain(Array.from(_, number$2)) : domain().map(date$1);
  };

  scale.ticks = function (interval) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
  };

  scale.tickFormat = function (count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function (interval) {
    var d = domain();
    if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
    return interval ? domain(nice(d, interval)) : scale;
  };

  scale.copy = function () {
    return copy(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
  };

  return scale;
}

function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, year, month, sunday, day, hour, minute, second, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
}

function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
}

var pi = Math.PI,
    tau$1 = 2 * pi,
    epsilon$1 = 1e-6,
    tauEpsilon = tau$1 - epsilon$1;

function Path$1() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath

  this._ = "";
}

function path() {
  return new Path$1();
}

Path$1.prototype = path.prototype = {
  constructor: Path$1,
  moveTo: function moveTo(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function lineTo(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function quadraticCurveTo(x1, y1, x, y) {
    this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x, y) {
    this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function arcTo(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01; // Is the radius negative? Error.

    if (r < 0) throw new Error("negative radius: " + r); // Is this path empty? Move to (x1,y1).

    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    } // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon$1)) ; // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
      // Equivalently, is (x1,y1) coincident with (x2,y2)?
      // Or, is the radius zero? Line to (x1,y1).
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) {
          this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        } // Otherwise, draw an arc!
        else {
            var x20 = x2 - x0,
                y20 = y2 - y0,
                l21_2 = x21 * x21 + y21 * y21,
                l20_2 = x20 * x20 + y20 * y20,
                l21 = Math.sqrt(l21_2),
                l01 = Math.sqrt(l01_2),
                l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
                t01 = l / l01,
                t21 = l / l21; // If the start tangent is not coincident with (x0,y0), line to.

            if (Math.abs(t01 - 1) > epsilon$1) {
              this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
            }

            this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
          }
  },
  arc: function arc(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0; // Is the radius negative? Error.

    if (r < 0) throw new Error("negative radius: " + r); // Is this path empty? Move to (x0,y0).

    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    } // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) {
        this._ += "L" + x0 + "," + y0;
      } // Is this arc empty? Were done.


    if (!r) return; // Does the angle go the wrong way? Flip the direction.

    if (da < 0) da = da % tau$1 + tau$1; // Is this a complete circle? Draw two arcs to complete the circle.

    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    } // Is this arc non-empty? Draw an arc!
    else if (da > epsilon$1) {
        this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
      }
  },
  rect: function rect(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + +w + "v" + +h + "h" + -w + "Z";
  },
  toString: function toString() {
    return this._;
  }
};

function constant$1(x) {
  return function constant() {
    return x;
  };
}

function array(x) {
  return typeof x === "object" && "length" in x ? x // Array, TypedArray, NodeList, array-like
  : Array.from(x); // Map, Set, iterable, string, or anything else
}

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
      // proceed

      default:
        this._context.lineTo(x, y);

        break;
    }
  }
};

function curveLinear(context) {
  return new Linear(context);
}

function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}

function line(x$1, y$1) {
  var defined = constant$1(true),
      context = null,
      curve = curveLinear,
      output = null;
  x$1 = typeof x$1 === "function" ? x$1 : x$1 === undefined ? x : constant$1(x$1);
  y$1 = typeof y$1 === "function" ? y$1 : y$1 === undefined ? y : constant$1(y$1);

  function line(data) {
    var i,
        n = (data = array(data)).length,
        d,
        defined0 = false,
        buffer;
    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();else output.lineEnd();
      }

      if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function (_) {
    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$1(+_), line) : x$1;
  };

  line.y = function (_) {
    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$1(+_), line) : y$1;
  };

  line.defined = function (_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$1(!!_), line) : defined;
  };

  line.curve = function (_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function (_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}

function area(x0, y0, y1) {
  var x1 = null,
      defined = constant$1(true),
      context = null,
      curve = curveLinear,
      output = null;
  x0 = typeof x0 === "function" ? x0 : x0 === undefined ? x : constant$1(+x0);
  y0 = typeof y0 === "function" ? y0 : y0 === undefined ? constant$1(0) : constant$1(+y0);
  y1 = typeof y1 === "function" ? y1 : y1 === undefined ? y : constant$1(+y1);

  function area(data) {
    var i,
        j,
        k,
        n = (data = array(data)).length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);
    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();

          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }

          output.lineEnd();
          output.areaEnd();
        }
      }

      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }

  area.x = function (_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), x1 = null, area) : x0;
  };

  area.x0 = function (_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), area) : x0;
  };

  area.x1 = function (_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : x1;
  };

  area.y = function (_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), y1 = null, area) : y0;
  };

  area.y0 = function (_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), area) : y0;
  };

  area.y1 = function (_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : y1;
  };

  area.lineX0 = area.lineY0 = function () {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function () {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function () {
    return arealine().x(x1).y(y0);
  };

  area.defined = function (_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$1(!!_), area) : defined;
  };

  area.curve = function (_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function (_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}

var defaultStyle$1 = {
  strokeWidth: 2,
  stroke: '#6b6b6b',
  fill: 'transparent',
  opacity: 1
};
var Path$2 = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var style = _ref.style,
      rest = _objectWithoutPropertiesLoose(_ref, ["style"]);

  var resolvedStyle = _extends({}, defaultStyle$1, style);

  return React.createElement("path", Object.assign({
    ref: ref
  }, rest, {
    style: resolvedStyle
  }));
});

var positionTop = "top";
var positionRight = "right";
var positionBottom = "bottom";
var positionLeft = "left";
var groupingSingle = "single";
var groupingSeries = "series";
var groupingPrimary = "primary";
var groupingSecondary = "secondary";
var alignAuto = "auto";
var alignRight = "right";
var alignTopRight = "topRight";
var alignBottomRight = "bottomRight";
var alignLeft = "left";
var alignTopLeft = "topLeft";
var alignBottomLeft = "bottomLeft";
var alignTop = "top";
var alignBottom = "bottom";
var axisTypeOrdinal = "ordinal";
var axisTypeTime = "time";
var axisTypeUtc = "utc";
var axisTypeLinear = "linear";
var axisTypeLog = "log";
var anchorPointer = "pointer";
var anchorClosest = "closest";
var anchorCenter = "center";
var anchorTop = "top";
var anchorBottom = "bottom";
var anchorLeft = "left";
var anchorRight = "right";
var anchorGridTop = "gridTop";
var anchorGridBottom = "gridBottom";
var anchorGridLeft = "gridLeft";
var anchorGridRight = "gridRight";
var focusAuto = "auto";
var focusClosest = "closest";
var focusElement = "element";

var lineFn = /*#__PURE__*/line();

var VoronoiElement = function VoronoiElement(_ref) {
  var children = _ref.children,
      rest = _objectWithoutPropertiesLoose(_ref, ["children"]);

  return React.createElement("g", Object.assign({
    className: "Voronoi"
  }, rest), children);
};

function Voronoi$1() {
  var _useChartContext = useChartContext(),
      stackData = _useChartContext.stackData,
      primaryAxes = _useChartContext.primaryAxes,
      secondaryAxes = _useChartContext.secondaryAxes,
      showVoronoi = _useChartContext.showVoronoi,
      width = _useChartContext.width,
      height = _useChartContext.height,
      gridWidth = _useChartContext.gridWidth,
      gridHeight = _useChartContext.gridHeight,
      onFocus = _useChartContext.onFocus,
      onClick = _useChartContext.onClick,
      tooltip = _useChartContext.tooltip,
      primaryCursor = _useChartContext.primaryCursor,
      secondaryCursor = _useChartContext.secondaryCursor,
      grouping = _useChartContext.grouping;

  var _useChartState = useChartState(function () {
    return null;
  }),
      setChartState = _useChartState[1];

  var handleFocus = React.useCallback(function (datum) {
    return setChartState(function (state) {
      return _extends({}, state, {
        focused: datum
      });
    });
  }, [setChartState]);
  var needsVoronoi = onFocus || onClick || tooltip || primaryCursor || secondaryCursor;
  return React.useMemo(function () {
    // Don't render until we have all dependencies
    if (!stackData || !primaryAxes.length || !secondaryAxes.length || !width || !height || !needsVoronoi) {
      return null;
    }

    var extent = [[0, 0], [gridWidth, gridHeight]];
    var props = {
      stackData: stackData,
      extent: extent,
      handleFocus: handleFocus,
      showVoronoi: showVoronoi,
      primaryAxes: primaryAxes
    };

    if (grouping === groupingPrimary) {
      return React.createElement(PrimaryVoronoi, Object.assign({}, props));
    }

    return React.createElement(ClosestVoronoi, Object.assign({}, props));
  }, [gridHeight, gridWidth, height, needsVoronoi, handleFocus, primaryAxes.length, secondaryAxes.length, showVoronoi, stackData, width]);
}

function PrimaryVoronoi(_ref2) {
  var stackData = _ref2.stackData,
      extent = _ref2.extent,
      handleFocus = _ref2.handleFocus,
      showVoronoi = _ref2.showVoronoi,
      primaryAxes = _ref2.primaryAxes;
  var primaryAxis = primaryAxes[0];
  var isVertical = primaryAxis.vertical;
  var datumBoundaries = [];
  stackData.forEach(function (series) {
    series.datums.filter(function (d) {
      return d.defined;
    }).forEach(function (datum) {
      var start;
      var end;
      datum.boundingPoints.forEach(function (boundingPoint) {
        var _start, _end;

        if (typeof datum.primaryCoord !== 'number' || typeof datum.secondaryCoord !== 'number' || Number.isNaN(datum.secondaryCoord) || Number.isNaN(datum.primaryCoord)) {
          return;
        }

        start = Math.min((_start = start) != null ? _start : datum.secondaryCoord, datum.secondaryCoord);
        end = Math.max((_end = end) != null ? _end : datum.secondaryCoord, datum.secondaryCoord);
      });
      datumBoundaries.push({
        start: start,
        end: end,
        datum: datum
      });
    });
  });
  var groupedBoundaries = new Map();
  datumBoundaries.forEach(function (datumBoundary) {
    if (!groupedBoundaries.has(datumBoundary.datum.primaryCoord)) {
      groupedBoundaries.set(datumBoundary.datum.primaryCoord, []);
    }

    var previous = groupedBoundaries.get(datumBoundary.datum.primaryCoord);
    groupedBoundaries.set(datumBoundary.datum.primaryCoord, [].concat(previous, [datumBoundary]));
  });
  var sortedPrimaryKeys = Array.from(groupedBoundaries.keys()).sort(function (a, b) {
    return a - b;
  });
  var columns = sortedPrimaryKeys.map(function (primaryKey, i) {
    var prev = sortedPrimaryKeys[i - 1];
    var next = sortedPrimaryKeys[i + 1];
    var primaryStart = 0;
    var primaryEnd = extent[1][isVertical ? 1 : 0];

    if (prev) {
      primaryStart = primaryKey - (primaryKey - prev) / 2;
    }

    if (next) {
      primaryEnd = primaryKey + (next - primaryKey) / 2;
    }

    var datumBoundaries = groupedBoundaries.get(primaryKey);
    return {
      primaryStart: primaryStart,
      primaryEnd: primaryEnd,
      primaryKey: primaryKey,
      datumBoundaries: datumBoundaries.map(function (datumBoundary, i) {
        var datum = datumBoundary.datum;
        var prev = datumBoundaries[i - 1];
        var next = datumBoundaries[i + 1];
        var secondaryStart = 0;
        var secondaryEnd = extent[1][isVertical ? 0 : 1];

        if (prev) {
          secondaryStart = datumBoundary.start - (datumBoundary.start - prev.end) / 2;
        }

        if (next) {
          secondaryEnd = datumBoundary.end + (next.start - datumBoundary.end) / 2;
        }

        return {
          secondaryStart: secondaryStart,
          secondaryEnd: secondaryEnd,
          datum: datum
        };
      })
    };
  });
  return React.createElement(VoronoiElement, null, columns.map(function (column) {
    return React.createElement(React.Fragment, {
      key: column.primaryKey
    }, column.datumBoundaries.map(function (datumBoundary) {
      var x1 = !isVertical ? column.primaryStart : datumBoundary.secondaryStart;
      var x2 = !isVertical ? column.primaryEnd : datumBoundary.secondaryEnd;
      var y1 = !isVertical ? datumBoundary.secondaryStart : column.primaryStart;
      var y2 = !isVertical ? datumBoundary.secondaryEnd : column.primaryEnd;
      return React.createElement(Rectangle, Object.assign({}, {
        key: column.primaryKey + "_" + datumBoundary.datum.seriesIndex,
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2,
        className: 'action-voronoi',
        onMouseEnter: function onMouseEnter(e) {
          return handleFocus(datumBoundary.datum);
        },
        onMouseLeave: function onMouseLeave(e) {
          return handleFocus(null);
        },
        style: {
          fill: 'rgba(0,0,0,.2)',
          stroke: 'rgba(255,255,255,.5)',
          strokeWidth: 1,
          opacity: showVoronoi ? 1 : 0
        }
      }));
    }));
  }));
}

function ClosestVoronoi(_ref3) {
  var stackData = _ref3.stackData,
      extent = _ref3.extent,
      handleFocus = _ref3.handleFocus,
      showVoronoi = _ref3.showVoronoi;
  var polygons = null;
  var voronoiData = [];
  stackData.forEach(function (series) {
    series.datums.filter(function (d) {
      return d.defined;
    }).forEach(function (datum) {
      datum.boundingPoints.forEach(function (boundingPoint) {
        if (typeof datum.x !== 'number' || typeof datum.y !== 'number' || Number.isNaN(datum.y) || Number.isNaN(datum.x)) {
          return;
        }

        voronoiData.push({
          x: boundingPoint.x,
          y: boundingPoint.y,
          datum: datum
        });
      });
    });
  });
  var delaunay = Delaunay.from(voronoiData, function (d) {
    return Math.max(d.x, 0);
  }, function (d) {
    return Math.max(d.y, 0);
  });
  var flatExtent = extent.flat().map(function (d) {
    return Math.max(d, 0);
  });
  var voronoi = delaunay.voronoi(flatExtent);
  polygons = voronoi.cellPolygons();
  polygons = Array.from(polygons);
  return React.createElement(VoronoiElement, null, polygons.map(function (points, i) {
    var index = points.index;
    var datum = voronoiData[index].datum;
    var path = lineFn(points);
    return React.createElement(Path$2, {
      key: i,
      d: path,
      className: "action-voronoi",
      onMouseEnter: function onMouseEnter(e) {
        return handleFocus(datum);
      },
      onMouseLeave: function onMouseLeave(e) {
        return handleFocus(null);
      },
      style: {
        fill: 'rgba(0,0,0,.2)',
        stroke: 'rgba(255,255,255,.5)',
        opacity: showVoronoi ? 1 : 0
      }
    });
  }));
}

var defaultStyle$2 = {
  strokeWidth: 1,
  fill: 'transparent',
  opacity: 1
};
var Line = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var style = _ref.style,
      rest = _objectWithoutPropertiesLoose(_ref, ["style"]);

  var resolvedStyle = _extends({}, defaultStyle$2, style);

  return React.createElement("line", Object.assign({
    ref: ref
  }, rest, {
    style: resolvedStyle
  }));
});

var defaultStyle$3 = {
  fontFamily: 'Helvetica',
  fontSize: 10,
  opacity: 1
};
var Text = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var style = _ref.style,
      rest = _objectWithoutPropertiesLoose(_ref, ["style"]);

  var resolvedStyle = _extends({}, defaultStyle$3, style);

  return React.createElement("text", Object.assign({
    ref: ref
  }, rest, {
    style: resolvedStyle
  }));
});

var Group = /*#__PURE__*/React.forwardRef(function (props, ref) {
  return React.createElement("g", Object.assign({
    ref: ref
  }, props));
});

var getElBox = function getElBox(el) {
  var rect = el.getBoundingClientRect();
  return {
    top: Math.round(rect.top),
    right: Math.round(rect.right),
    bottom: Math.round(rect.bottom),
    left: Math.round(rect.left),
    width: Math.round(rect.width),
    height: Math.round(rect.height),
    x: Math.round(rect.x),
    y: Math.round(rect.y)
  };
};

function useIsLooping() {
  var callThreshold = 30;
  var timeLimit = 500;
  var now = Date.now();
  var ref = React.useRef([now]);
  ref.current.push(now);
  ref.current = ref.current.filter(function (d) {
    return d > now - timeLimit;
  });

  while (ref.current.length > callThreshold) {
    ref.current.shift();
  }

  var isLooping = ref.current.length === callThreshold && now - ref.current[0] < timeLimit;
  return isLooping;
}

function useMeasure(_ref) {
  var elRef = _ref.elRef,
      rotation = _ref.rotation,
      showRotated = _ref.showRotated,
      setShowRotated = _ref.setShowRotated,
      id = _ref.id,
      position = _ref.position,
      tickSizeInner = _ref.tickSizeInner,
      tickSizeOuter = _ref.tickSizeOuter,
      labelRotation = _ref.labelRotation,
      tickPadding = _ref.tickPadding,
      vertical = _ref.vertical,
      gridWidth = _ref.gridWidth,
      gridHeight = _ref.gridHeight,
      show = _ref.show;

  var _useChartState = useChartState(function (state) {
    var _state$axisDimensions, _state$axisDimensions2;

    return (_state$axisDimensions = state.axisDimensions) == null ? void 0 : (_state$axisDimensions2 = _state$axisDimensions[position]) == null ? void 0 : _state$axisDimensions2[id];
  }),
      axisDimension = _useChartState[0],
      setChartState = _useChartState[1];

  var isLooping = useIsLooping();
  var measureDimensions = React.useCallback(function () {
    if (!elRef.current) {
      return;
    } // if (show) {
    //   // Remeasure when show changes
    // }


    var gridSize = !vertical ? gridWidth : gridHeight;
    var unrotatedLabelDims = Array.apply(void 0, elRef.current.querySelectorAll('.Axis.unrotated .tickLabel')).map(function (el) {
      return getElBox(el);
    }); // Determine the largest labels on the axis

    var widestLabel = unrotatedLabelDims.reduce(function (label, d) {
      label = label || d;

      if (d.width > 0 && d.width > label.width) {
        label = d;
      }

      return label;
    }, null);
    var smallestTickGap = gridSize;

    if (unrotatedLabelDims.length > 1) {
      unrotatedLabelDims.reduce(function (prev, current) {
        if (prev) {
          smallestTickGap = Math.min(smallestTickGap, vertical ? current.top - prev.top : current.left - prev.left);
        }

        return current;
      }, false);
    }

    var shouldRotate = ((widestLabel == null ? void 0 : widestLabel.width) || 0) + tickPadding > smallestTickGap;

    if (!isLooping) {
      // Rotate ticks for non-time horizontal axes
      if (!vertical) {
        setShowRotated(shouldRotate);
      }
    }
  }, [axisDimension, elRef, gridHeight, gridWidth, id, labelRotation, position, rotation, setChartState, show, tickPadding, tickSizeInner, tickSizeOuter, vertical]); // Measure after if needed

  useIsomorphicLayoutEffect(function () {
    measureDimensions();
  });
  useIsomorphicLayoutEffect(function () {
    if (!elRef.current) {
      if (axisDimension) {
        // If the entire axis is hidden, then we need to remove the axis dimensions
        setChartState(function (state) {
          var _extends2;

          var newAxes = state.axisDimensions[position] || {};
          delete newAxes[id];
          return _extends({}, state, {
            axisDimensions: _extends({}, state.axisDimensions, (_extends2 = {}, _extends2[position] = newAxes, _extends2))
          });
        });
      }

      return;
    }

    var newDimensions = {
      width: 0,
      height: 0,
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    };
    var domainDims = getElBox(elRef.current.querySelector(".Axis." + (showRotated ? 'rotated' : 'unrotated') + " .domain"));
    var measureDims = showRotated ? Array.apply(void 0, elRef.current.querySelectorAll('.Axis.rotated .tickLabel')).map(function (el) {
      return getElBox(el);
    }) : Array.apply(void 0, elRef.current.querySelectorAll('.Axis.unrotated .tickLabel')).map(function (el) {
      return getElBox(el);
    }); // Determine the largest labels on the axis

    var _measureDims$reduce = measureDims.reduce(function (labels, d) {
      var _labels$ = labels[0],
          largestW = _labels$ === void 0 ? d : _labels$,
          _labels$2 = labels[1],
          largestH = _labels$2 === void 0 ? d : _labels$2;

      if (d.width > 0 && d.width > largestW.width) {
        largestW = d;
      }

      if (d.height > 0 && d.height > largestH.height) {
        largestH = d;
      }

      return [largestW, largestH];
    }, []),
        widestRealLabel = _measureDims$reduce[0],
        tallestRealLabel = _measureDims$reduce[1]; // Axis overflow measurements


    if (!vertical) {
      var _tallestRealLabel$hei;

      if (measureDims.length) {
        var leftMostLabelDim = measureDims.reduce(function (d, labelDim) {
          return labelDim.left < d.left ? labelDim : d;
        });
        var rightMostLabelDim = measureDims.reduce(function (d, labelDim) {
          return labelDim.right > d.right ? labelDim : d;
        });
        newDimensions.left = Math.round(Math.max(0, domainDims.left - (leftMostLabelDim == null ? void 0 : leftMostLabelDim.left)));
        newDimensions.right = Math.round(Math.max(0, (rightMostLabelDim == null ? void 0 : rightMostLabelDim.right) - domainDims.right));
      }

      newDimensions.height = Math.round(Math.max(tickSizeInner, tickSizeOuter) + tickPadding + ((_tallestRealLabel$hei = tallestRealLabel == null ? void 0 : tallestRealLabel.height) != null ? _tallestRealLabel$hei : 0));
    } else {
      var _widestRealLabel$widt;

      if (measureDims.length) {
        var topMostLabelDim = measureDims.reduce(function (d, labelDim) {
          return labelDim.top < d.top ? labelDim : d;
        });
        var bottomMostLabelDim = measureDims.reduce(function (d, labelDim) {
          return labelDim.bottom > d.bottom ? labelDim : d;
        });
        newDimensions.top = Math.round(Math.max(0, domainDims.top - (topMostLabelDim == null ? void 0 : topMostLabelDim.top)));
        newDimensions.bottom = Math.round(Math.max(0, (bottomMostLabelDim == null ? void 0 : bottomMostLabelDim.bottom) - domainDims.bottom));
      }

      newDimensions.width = Math.round(Math.max(tickSizeInner, tickSizeOuter) + tickPadding + ((_widestRealLabel$widt = widestRealLabel == null ? void 0 : widestRealLabel.width) != null ? _widestRealLabel$widt : 0));
    } // Only update the axisDimensions if something has changed


    if (!axisDimension || Object.keys(newDimensions).some(function (key) {
      return newDimensions[key] !== axisDimension[key];
    })) {
      setChartState(function (state) {
        var _extends3, _extends4;

        return _extends({}, state, {
          axisDimensions: _extends({}, state.axisDimensions, (_extends4 = {}, _extends4[position] = _extends({}, state.axisDimensions[position] || {}, (_extends3 = {}, _extends3[id] = newDimensions, _extends3)), _extends4))
        });
      });
    }
  });
}

var defaultStyles = {
  line: {
    strokeWidth: '1',
    fill: 'transparent'
  },
  tick: {
    fontSize: 10,
    fontFamily: 'sans-serif'
  }
};
function AxisLinear(axis) {
  var type = axis.type,
      position = axis.position,
      tickSizeInner = axis.tickSizeInner,
      tickSizeOuter = axis.tickSizeOuter,
      show = axis.show,
      showGrid = axis.showGrid,
      showTicks = axis.showTicks,
      styles = axis.styles,
      ticks = axis.ticks,
      scale = axis.scale,
      scaleMax = axis.max,
      transform = axis.transform,
      vertical = axis.vertical,
      format = axis.format,
      _axis$range = axis.range,
      range0 = _axis$range[0],
      range1 = _axis$range[1],
      directionMultiplier = axis.directionMultiplier,
      tickOffset = axis.tickOffset,
      gridOffset = axis.gridOffset,
      spacing = axis.spacing,
      labelRotation = axis.labelRotation;

  var _React$useState = React.useState(false),
      showRotated = _React$useState[0],
      setShowRotated = _React$useState[1];

  var _React$useState2 = React.useState(0),
      rotation = _React$useState2[0],
      setRotation = _React$useState2[1];

  var _useChartContext = useChartContext(),
      gridWidth = _useChartContext.gridWidth,
      gridHeight = _useChartContext.gridHeight,
      dark = _useChartContext.dark;

  var elRef = React.useRef();
  useMeasure(_extends({}, axis, {
    elRef: elRef,
    rotation: rotation,
    gridWidth: gridWidth,
    gridHeight: gridHeight,
    setRotation: setRotation,
    showRotated: showRotated,
    setShowRotated: setShowRotated
  })); // Not ready? Render null

  if (!show) {
    return null;
  }

  var axisPath;

  if (vertical) {
    if (position === positionLeft) {
      axisPath = "\n        M " + -tickSizeOuter + ", " + range0 + "\n        H 0\n        V " + range1 + "\n        H " + -tickSizeOuter + "\n      ";
    } else {
      axisPath = "\n        M " + tickSizeOuter + ", " + range0 + "\n        H 0\n        V " + range1 + "\n        H " + tickSizeOuter + "\n      ";
    }
  } else if (position === positionBottom) {
    axisPath = "\n        M 0, " + tickSizeOuter + "\n        V 0\n        H " + range1 + "\n        V " + tickSizeOuter + "\n      ";
  } else {
    axisPath = "\n        M 0, " + -tickSizeOuter + "\n        V 0\n        H " + range1 + "\n        V " + -tickSizeOuter + "\n              ";
  }

  var showGridLine;

  if (typeof showGrid === 'boolean') {
    showGridLine = showGrid;
  } else if (type === axisTypeOrdinal) {
    showGridLine = false;
  } else {
    showGridLine = true;
  } // Combine default styles with style props


  var axisStyles = _extends({}, defaultStyles, styles);

  var renderAxis = function renderAxis(isRotated) {
    var show = isRotated ? showRotated : !showRotated;
    return React.createElement(Group, {
      className: "Axis " + (isRotated ? 'rotated' : 'unrotated'),
      style: _extends({
        transform: position === positionRight ? translateX(gridWidth) : position === positionBottom ? translateY(gridHeight) : undefined
      }, show ? {
        opacity: 1,
        pointerEvents: 'all'
      } : {
        opacity: 0,
        pointerEvents: 'none'
      })
    }, React.createElement(Path$2, {
      className: "domain",
      d: axisPath,
      style: _extends({
        stroke: dark ? 'rgba(255,255,255, .1)' : 'rgba(0,0,0, .1)'
      }, axisStyles.line)
    }), React.createElement(Group, {
      className: "ticks"
    }, ticks.map(function (tick, i) {
      return React.createElement(Group, {
        key: [String(tick), i].join('_'),
        className: "tick",
        style: {
          transform: transform(scale(tick) || 0)
        }
      }, showGridLine && React.createElement(Line, {
        className: "gridLine",
        x1: vertical ? 0 : gridOffset,
        x2: vertical ? scaleMax : gridOffset,
        y1: vertical ? gridOffset : 0,
        y2: vertical ? gridOffset : scaleMax,
        style: _extends({
          stroke: dark ? 'rgba(255,255,255, .05)' : 'rgba(0,0,0, .05)',
          strokeWidth: 1
        }, axisStyles.line)
      }), showTicks ? React.createElement("g", {
        className: "labelGroup"
      }, React.createElement(Line, {
        className: "tickline",
        x1: vertical ? 0 : tickOffset,
        x2: vertical ? directionMultiplier * tickSizeInner : tickOffset,
        y1: vertical ? tickOffset : 0,
        y2: vertical ? tickOffset : directionMultiplier * tickSizeInner,
        style: _extends({
          stroke: dark ? 'rgba(255,255,255, .1)' : 'rgba(0,0,0, .1)',
          strokeWidth: 1
        }, axisStyles.line)
      }), React.createElement(Text, {
        className: "tickLabel",
        style: _extends({
          fill: dark ? 'white' : 'black'
        }, axisStyles.tick, {
          transform: translate(vertical ? directionMultiplier * spacing : tickOffset, vertical ? tickOffset : directionMultiplier * spacing) + " rotate(" + (isRotated ? position === 'top' ? labelRotation : -labelRotation : 0) + "deg)"
        }),
        dominantBaseline: isRotated ? 'central' : position === positionBottom ? 'hanging' : position === positionTop ? 'alphabetic' : 'central',
        textAnchor: isRotated ? 'end' : position === positionRight ? 'start' : position === positionLeft ? 'end' : 'middle'
      }, format(tick, i))) : null);
    })));
  };

  return React.createElement(Group, {
    ref: elRef
  }, renderAxis(false), renderAxis(true));
}

function Axis(props) {
  return React.createElement(AxisLinear, Object.assign({}, props));
}

var triangleSize = 7;

var getBackgroundColor = function getBackgroundColor(dark) {
  return dark ? 'rgba(255,255,255,.9)' : 'rgba(0, 26, 39, 0.9)';
};

function Tooltip() {
  var chartContext = useChartContext();
  var primaryAxes = chartContext.primaryAxes,
      secondaryAxes = chartContext.secondaryAxes,
      gridX = chartContext.gridX,
      gridY = chartContext.gridY,
      gridWidth = chartContext.gridWidth,
      gridHeight = chartContext.gridHeight,
      dark = chartContext.dark,
      focused = chartContext.focused,
      latestFocused = chartContext.latestFocused,
      getDatumStyle = chartContext.getDatumStyle,
      tooltip = chartContext.tooltip;
  var elRef = React.useRef();
  var tooltipElRef = React.useRef();
  var previousShowRef = React.useRef();

  var _ref = tooltip || {},
      align = _ref.align,
      alignPriority = _ref.alignPriority,
      padding = _ref.padding,
      tooltipArrowPadding = _ref.tooltipArrowPadding,
      arrowPosition = _ref.arrowPosition,
      render = _ref.render,
      anchor = _ref.anchor,
      show = _ref.show;

  var _React$useState = React.useState(align || 'auto'),
      finalAlign = _React$useState[0],
      setFinalAlign = _React$useState[1];

  React.useEffect(function () {
    previousShowRef.current = show;
  }, [show]);
  useIsomorphicLayoutEffect(function () {
    if (align !== 'auto' || !elRef.current || !show || !anchor) {
      return;
    }

    var space = {
      left: Infinity,
      top: Infinity,
      right: Infinity,
      bottom: Infinity
    };
    var container = elRef.current;
    var gridDims = container.getBoundingClientRect();
    var tooltipDims = tooltipElRef.current.getBoundingClientRect();

    while (container !== document.body) {
      container = container.parentElement;

      var _window$getComputedSt = window.getComputedStyle(container),
          overflowX = _window$getComputedSt.overflowX,
          overflowY = _window$getComputedSt.overflowY;

      if (container === document.body || [overflowX, overflowY].find(function (d) {
        return ['auto', 'hidden'].includes(d);
      })) {
        var containerDims = container.getBoundingClientRect();
        var left = gridDims.left - containerDims.left + anchor.x;
        var top = gridDims.top - containerDims.top + anchor.y;
        var right = containerDims.width - left;
        var bottom = containerDims.height - top;
        space.left = Math.min(space.left, left);
        space.top = Math.min(space.top, top);
        space.right = Math.min(space.right, right);
        space.bottom = Math.min(space.bottom, bottom);
      }
    }

    var resolvedAlign = null;
    alignPriority.forEach(function (priority) {
      if (resolvedAlign) {
        return;
      }

      var fits = {
        left: space.left - tooltipArrowPadding - padding - anchor.horizontalPadding > tooltipDims.width,
        right: space.right - tooltipArrowPadding - padding - anchor.horizontalPadding > tooltipDims.width,
        top: space.top - tooltipArrowPadding - padding - anchor.verticalPadding > tooltipDims.height && space.left > tooltipDims.width / 2,
        bottom: space.bottom - tooltipArrowPadding - padding - anchor.verticalPadding > tooltipDims.height,
        centeredFromLeft: space.left > tooltipDims.width / 2,
        centeredFromRight: space.right > tooltipDims.width / 2,
        centeredFromTop: space.top > tooltipDims.height / 2,
        centeredFromBottom: space.bottom > tooltipDims.height / 2
      };

      if (priority === 'left') {
        if (fits.left && fits.centeredFromTop && fits.centeredFromBottom) {
          resolvedAlign = priority;
        }
      } else if (priority === 'right') {
        if (fits.right && fits.centeredFromTop && fits.centeredFromBottom) {
          resolvedAlign = priority;
        }
      } else if (priority === 'top') {
        if (fits.top && fits.centeredFromLeft && fits.centeredFromRight) {
          resolvedAlign = priority;
        }
      } else if (priority === 'bottom') {
        if (fits.bottom && fits.centeredFromLeft && fits.centeredFromRight) {
          resolvedAlign = priority;
        }
      } else if (priority === 'topLeft') {
        if (fits.top && fits.left) {
          resolvedAlign = priority;
        }
      } else if (priority === 'topRight') {
        if (fits.top && fits.right) {
          resolvedAlign = priority;
        }
      } else if (priority === 'bottomLeft') {
        if (fits.bottom && fits.left) {
          resolvedAlign = priority;
        }
      } else if (priority === 'bottomRight') {
        if (fits.bottom && fits.right) {
          resolvedAlign = priority;
        }
      }
    });

    if (resolvedAlign !== finalAlign) {
      setFinalAlign(resolvedAlign);
    }
  }, [align, alignPriority, anchor, finalAlign, padding, show, tooltipArrowPadding]);

  if (!tooltip) {
    return null;
  }

  var resolvedFocused = focused || latestFocused;
  var alignX = 0;
  var alignY = -50;
  var triangleStyles = {};
  var backgroundColor = getBackgroundColor(dark);
  var resolvedArrowPosition = arrowPosition;

  if (finalAlign === 'top') {
    alignX = -50;
    alignY = -100;
  } else if (finalAlign === 'topRight') {
    alignX = 0;
    alignY = -100;
  } else if (finalAlign === 'right') {
    alignX = 0;
    alignY = -50;
  } else if (finalAlign === 'bottomRight') {
    alignX = 0;
    alignY = 0;
  } else if (finalAlign === 'bottom') {
    alignX = -50;
    alignY = 0;
  } else if (finalAlign === 'bottomLeft') {
    alignX = -100;
    alignY = 0;
  } else if (finalAlign === 'left') {
    alignX = -100;
    alignY = -50;
  } else if (finalAlign === 'topLeft') {
    alignX = -100;
    alignY = -100;
  } else if (finalAlign === 'center') {
    alignX = -50;
    alignY = -50;
  }

  if (!resolvedArrowPosition) {
    if (finalAlign === 'left') {
      resolvedArrowPosition = 'right';
    } else if (finalAlign === 'right') {
      resolvedArrowPosition = 'left';
    } else if (finalAlign === 'top') {
      resolvedArrowPosition = 'bottom';
    } else if (finalAlign === 'bottom') {
      resolvedArrowPosition = 'top';
    } else if (finalAlign === 'topRight') {
      resolvedArrowPosition = 'bottomLeft';
    } else if (finalAlign === 'bottomRight') {
      resolvedArrowPosition = 'topLeft';
    } else if (finalAlign === 'topLeft') {
      resolvedArrowPosition = 'bottomRight';
    } else if (finalAlign === 'bottomLeft') {
      resolvedArrowPosition = 'topRight';
    }
  }

  if (resolvedArrowPosition === 'bottom') {
    triangleStyles = {
      top: '100%',
      left: '50%',
      transform: 'translate3d(-50%, 0%, 0)',
      borderLeft: triangleSize * 0.8 + "px solid transparent",
      borderRight: triangleSize * 0.8 + "px solid transparent",
      borderTop: triangleSize + "px solid " + backgroundColor
    };
  } else if (resolvedArrowPosition === 'top') {
    triangleStyles = {
      top: '0%',
      left: '50%',
      transform: 'translate3d(-50%, -100%, 0)',
      borderLeft: triangleSize * 0.8 + "px solid transparent",
      borderRight: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize + "px solid " + backgroundColor
    };
  } else if (resolvedArrowPosition === 'right') {
    triangleStyles = {
      top: '50%',
      left: '100%',
      transform: 'translate3d(0%, -50%, 0)',
      borderTop: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize * 0.8 + "px solid transparent",
      borderLeft: triangleSize + "px solid " + backgroundColor
    };
  } else if (resolvedArrowPosition === 'left') {
    triangleStyles = {
      top: '50%',
      left: '0%',
      transform: 'translate3d(-100%, -50%, 0)',
      borderTop: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize * 0.8 + "px solid transparent",
      borderRight: triangleSize + "px solid " + backgroundColor
    };
  } else if (resolvedArrowPosition === 'topRight') {
    triangleStyles = {
      top: '0%',
      left: '100%',
      transform: 'translate3d(-50%, -50%, 0) rotate(-45deg)',
      borderTop: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize * 0.8 + "px solid transparent",
      borderLeft: triangleSize * 2 + "px solid " + backgroundColor
    };
  } else if (resolvedArrowPosition === 'bottomRight') {
    triangleStyles = {
      top: '100%',
      left: '100%',
      transform: 'translate3d(-50%, -50%, 0) rotate(45deg)',
      borderTop: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize * 0.8 + "px solid transparent",
      borderLeft: triangleSize * 2 + "px solid " + backgroundColor
    };
  } else if (resolvedArrowPosition === 'topLeft') {
    triangleStyles = {
      top: '0%',
      left: '0%',
      transform: 'translate3d(-50%, -50%, 0) rotate(45deg)',
      borderTop: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize * 0.8 + "px solid transparent",
      borderRight: triangleSize * 2 + "px solid " + backgroundColor
    };
  } else if (resolvedArrowPosition === 'bottomLeft') {
    triangleStyles = {
      top: '100%',
      left: '0%',
      transform: 'translate3d(-50%, -50%, 0) rotate(-45deg)',
      borderTop: triangleSize * 0.8 + "px solid transparent",
      borderBottom: triangleSize * 0.8 + "px solid transparent",
      borderRight: triangleSize * 2 + "px solid " + backgroundColor
    };
  } else {
    triangleStyles = {
      opacity: 0
    };
  }

  var primaryAxis = getAxisByAxisId(primaryAxes, resolvedFocused ? resolvedFocused.series.primaryAxisId : null);
  var secondaryAxis = getAxisByAxisId(secondaryAxes, resolvedFocused ? resolvedFocused.series.secondaryAxisId : null);
  var resolvedHorizontalPadding = padding + anchor.horizontalPadding;
  var resolvedVerticalPadding = padding + anchor.verticalPadding;

  var renderProps = _extends({}, chartContext, chartContext.tooltip, {
    datum: resolvedFocused,
    getStyle: function getStyle(datum) {
      return datum.getStatusStyle(resolvedFocused, getDatumStyle);
    },
    primaryAxis: primaryAxis,
    secondaryAxis: secondaryAxis
  });

  var renderedChildren = React.createElement(render, renderProps);
  var animateCoords;

  if (previousShowRef.current === show) {
    animateCoords = true;
  }

  return React.createElement("div", {
    className: "tooltip-wrap",
    style: {
      pointerEvents: 'none',
      position: 'absolute',
      left: gridX + "px",
      top: gridY + "px",
      width: gridWidth + "px",
      height: gridHeight + "px",
      opacity: show ? 1 : 0,
      transition: 'all .3s ease'
    },
    ref: function ref(el) {
      elRef.current = el;
    }
  }, React.createElement("div", {
    style: {
      position: 'absolute',
      left: 0,
      top: 0,
      transform: translate(anchor.x, anchor.y),
      transition: animateCoords ? 'all .2s ease' : 'opacity .2s ease'
    }
  }, React.createElement("div", {
    style: {
      transform: "translate3d(" + alignX + "%, " + alignY + "%, 0)",
      padding: tooltipArrowPadding + resolvedVerticalPadding + "px " + (tooltipArrowPadding + resolvedHorizontalPadding) + "px",
      width: 'auto',
      transition: 'all .2s ease'
    }
  }, React.createElement("div", {
    ref: function ref(el) {
      tooltipElRef.current = el;
    },
    style: {
      fontSize: '12px',
      padding: '5px',
      background: getBackgroundColor(dark),
      color: dark ? 'black' : 'white',
      borderRadius: '3px',
      position: 'relative'
    }
  }, React.createElement("div", {
    style: _extends({
      position: 'absolute',
      width: 0,
      height: 0
    }, triangleStyles, {
      transition: animateCoords ? 'all .2s ease' : 'none'
    })
  }), renderedChildren))));
}

var getLineBackgroundColor = function getLineBackgroundColor(dark) {
  return dark ? 'rgba(255,255,255,.3)' : 'rgba(0, 26, 39, 0.3)';
};

var getBackgroundColor$1 = function getBackgroundColor(dark) {
  return dark ? 'rgba(255,255,255,.9)' : 'rgba(0, 26, 39, 0.9)';
};

function Cursor(_ref) {
  var primary = _ref.primary;

  var _useChartContext = useChartContext(),
      focused = _useChartContext.focused,
      latestFocused = _useChartContext.latestFocused,
      primaryCursor = _useChartContext.primaryCursor,
      secondaryCursor = _useChartContext.secondaryCursor,
      gridX = _useChartContext.gridX,
      gridY = _useChartContext.gridY,
      dark = _useChartContext.dark;

  var resolvedFocused = focused || latestFocused;
  var cursor = primary ? primaryCursor : secondaryCursor;

  var _ref2 = cursor || {},
      showLine = _ref2.showLine,
      showLabel = _ref2.showLabel,
      resolvedValue = _ref2.resolvedValue,
      snap = _ref2.snap,
      render = _ref2.render,
      axis = _ref2.axis,
      siblingAxis = _ref2.siblingAxis,
      resolvedShow = _ref2.resolvedShow;

  var latestValue = useLatest(resolvedValue, typeof resolvedValue !== 'undefined');
  var previousShowRef = React.useRef();
  React.useEffect(function () {
    previousShowRef.current = resolvedShow;
  }, [resolvedShow]);

  if (!cursor) {
    return null;
  } // Should we animate?


  var animated = snap || axis.type === 'ordinal'; // Get the sibling range

  var siblingRange = siblingAxis.scale.range();
  var x;
  var y;
  var x1;
  var x2;
  var y1;
  var y2;
  var alignPctX;
  var alignPctY; // Vertical alignment

  if (axis.vertical) {
    y = axis.scale(latestValue);
    y1 = y - 1;
    y2 = y + axis.cursorSize + 1;

    if (axis.position === 'left') {
      x1 = siblingRange[0];
      x2 = siblingRange[1];
    } else {
      x1 = siblingRange[1];
      x2 = siblingRange[0];
    }
  } else {
    x = axis.scale(latestValue);
    x1 = x - 1;
    x2 = x + axis.cursorSize + 1;

    if (axis.position === 'top') {
      y1 = siblingRange[0];
      y2 = siblingRange[1];
    } else {
      y1 = siblingRange[1];
      y2 = siblingRange[0];
    }
  }

  var lineStartX = Math.min(x1, x2);
  var lineStartY = Math.min(y1, y2);
  var lineEndX = Math.max(x1, x2);
  var lineEndY = Math.max(y1, y2);
  var lineHeight = Math.max(lineEndY - lineStartY, 0);
  var lineWidth = Math.max(lineEndX - lineStartX, 0);
  var bubbleX;
  var bubbleY; // Bubble placement

  if (axis.vertical) {
    if (axis.position === 'left') {
      if (!axis.RTL) {
        bubbleX = lineStartX;
      } else {
        bubbleX = lineEndX;
      }
    } else {
      if (!axis.RTL) {
        bubbleX = lineEndX;
      } else {
        bubbleX = lineStartX;
      }
    }

    bubbleY = lineStartY + lineHeight / 2;
  } else {
    bubbleX = lineStartX + lineWidth / 2;

    if (axis.position === 'top') {
      bubbleY = lineStartY;
    } else {
      bubbleY = lineEndY;
    }
  } // Bubble anchoring


  if (axis.vertical) {
    alignPctY = -50;

    if (axis.position === 'left') {
      alignPctX = -100;
    } else {
      alignPctX = 0;
    }
  } else {
    alignPctX = -50;

    if (axis.position === 'top') {
      alignPctY = -100;
    } else {
      alignPctY = 0;
    }
  }

  var renderProps = _extends({}, cursor);

  renderProps.formattedValue = String(axis.vertical ? typeof latestValue !== 'undefined' ? axis.format(axis.stacked && !primary && resolvedFocused ? resolvedFocused.totalValue : latestValue) : '' : typeof latestValue !== 'undefined' ? axis.format(axis.stacked && !primary && resolvedFocused ? resolvedFocused.totalValue : latestValue) : ''); // if (!axis.vertical) {
  // console.log({ bubbleX, bubbleY });
  // }

  var animateCoords;

  if (previousShowRef.current === resolvedShow) {
    animateCoords = true;
  }

  var renderedChildren = render(renderProps);
  return React.createElement("div", {
    style: {
      pointerEvents: 'none',
      position: 'absolute',
      top: 0,
      left: 0,
      transform: translate(gridX, gridY),
      opacity: resolvedShow ? 1 : 0,
      transition: 'all .3s ease'
    },
    className: "Cursor"
  }, showLine ? React.createElement("div", {
    style: {
      position: 'absolute',
      top: 0,
      left: 0,
      transform: translate(lineStartX, lineStartY),
      width: lineWidth + "px",
      height: lineHeight + "px",
      background: getLineBackgroundColor(dark),
      transition: animated && animateCoords ? 'all .2s ease' : 'opacity .2s ease'
    }
  }) : null, showLabel ? React.createElement("div", {
    style: {
      position: 'absolute',
      top: 0,
      left: 0,
      transform: translate(bubbleX, bubbleY),
      transition: animated && animateCoords ? 'all .2s ease' : 'opacity .2s ease'
    }
  }, React.createElement("div", {
    style: {
      padding: '5px',
      fontSize: '10px',
      background: getBackgroundColor$1(dark),
      color: getBackgroundColor$1(!dark),
      borderRadius: '3px',
      position: 'relative',
      transform: "translate3d(" + alignPctX + "%, " + alignPctY + "%, 0)",
      whiteSpace: 'nowrap'
    }
  }, renderedChildren)) : null);
}

function Brush() {
  var _useChartContext = useChartContext(),
      brush = _useChartContext.brush,
      gridX = _useChartContext.gridX,
      gridY = _useChartContext.gridY,
      gridHeight = _useChartContext.gridHeight,
      dark = _useChartContext.dark;

  var _useChartState = useChartState(function (d) {
    return d.pointer;
  }),
      pointer = _useChartState[0];

  if (!brush) {
    return null;
  }

  return React.createElement("div", {
    className: "Brush",
    style: {
      pointerEvents: 'none',
      position: 'absolute',
      left: 0,
      top: 0,
      transform: translate(gridX, gridY),
      opacity: pointer.dragging ? Math.abs(pointer.sourceX - pointer.x) < 20 ? 0.5 : 1 : 0
    }
  }, React.createElement("div", {
    style: _extends({
      position: 'absolute',
      transform: translate(Math.min(pointer.x, pointer.sourceX), 0),
      width: Math.abs(pointer.x - pointer.sourceX) + "px",
      height: gridHeight + "px",
      background: dark ? 'rgba(255,255,255,.3)' : 'rgba(0, 26, 39, 0.3)'
    }, brush.style)
  }));
}

var ChartInner = /*#__PURE__*/React.forwardRef(function ChartInner(_ref, ref) {
  var className = _ref.className,
      _ref$style = _ref.style,
      style = _ref$style === void 0 ? {} : _ref$style,
      rest = _objectWithoutPropertiesLoose(_ref, ["className", "style"]);

  var svgRef = React.useRef();

  var _useChartContext = useChartContext(),
      width = _useChartContext.width,
      height = _useChartContext.height,
      gridX = _useChartContext.gridX,
      gridY = _useChartContext.gridY,
      stackData = _useChartContext.stackData,
      primaryAxes = _useChartContext.primaryAxes,
      secondaryAxes = _useChartContext.secondaryAxes,
      renderSVG = _useChartContext.renderSVG,
      seriesOptions = _useChartContext.seriesOptions,
      getSeriesOrder = _useChartContext.getSeriesOrder,
      focused = _useChartContext.focused,
      getOnClick = _useChartContext.getOnClick;

  var _useChartState = useChartState(function (d) {
    return d.offset;
  }),
      offset = _useChartState[0];

  var _useChartState2 = useChartState(function (d) {
    return d.setOffset;
  }),
      setOffset = _useChartState2[0],
      setChartState = _useChartState2[1];

  useIsomorphicLayoutEffect(function () {
    if (!svgRef.current) {
      return;
    }

    var current = svgRef.current.getBoundingClientRect();

    if (current.left !== offset.left || current.top !== offset.top) {
      setOffset({
        left: current.left,
        top: current.top
      });
    }
  });

  var _onMouseLeave = function onMouseLeave(e) {
    setChartState(function (old) {
      return _extends({}, old, {
        focused: null
      });
    });
    setChartState(function (old) {
      return _extends({}, old, {
        pointer: _extends({}, old.pointer, {
          active: false
        })
      });
    });
  };

  var rafRef = React.useRef();

  var _onMouseMove = function onMouseMove(e) {
    if (rafRef.current) {
      Raf.cancel(rafRef.current);
    }

    rafRef.current = Raf(function () {
      rafRef.current = null;
      var clientX = e.clientX,
          clientY = e.clientY;
      setChartState(function (old) {
        var _old$pointer;

        var x = clientX - offset.left - gridX;
        var y = clientY - offset.top - gridY;

        var pointer = _extends({}, old.pointer, {
          active: true,
          x: x,
          y: y,
          dragging: (_old$pointer = old.pointer) == null ? void 0 : _old$pointer.down
        });

        return _extends({}, old, {
          pointer: pointer
        });
      });
    });
  };

  var onMouseUp = function onMouseUp() {
    document.removeEventListener('mouseup', onMouseUp);
    document.removeEventListener('mousemove', _onMouseMove);
    setChartState(function (old) {
      return _extends({}, old, {
        pointer: _extends({}, old.pointer, {
          down: false,
          dragging: false,
          released: {
            x: old.pointer.x,
            y: old.pointer.y
          }
        })
      });
    });
  };

  var _onMouseDown = function onMouseDown() {
    document.addEventListener('mouseup', onMouseUp);
    document.addEventListener('mousemove', _onMouseMove);
    setChartState(function (old) {
      return _extends({}, old, {
        pointer: _extends({}, old.pointer, {
          sourceX: old.pointer.x,
          sourceY: old.pointer.y,
          down: true
        })
      });
    });
  }; // Reverse the stack order for proper z-indexing


  var reversedStackData = [].concat(stackData).reverse();
  var orderedStackData = getSeriesOrder(reversedStackData);
  var focusedSeriesIndex = focused ? orderedStackData.findIndex(function (series) {
    return series.id === focused.series.id;
  }) : -1; // Bring focused series to the front

  var focusOrderedStackData = focused ? [].concat(orderedStackData.slice(0, focusedSeriesIndex), orderedStackData.slice(focusedSeriesIndex + 1), [orderedStackData[focusedSeriesIndex]]) : orderedStackData;
  var stacks = focusOrderedStackData.map(function (stack) {
    return React.createElement(stack.Component, Object.assign({
      key: stack.id
    }, seriesOptions[stack.index], {
      series: stack,
      stackData: stackData
    }));
  });
  useIsomorphicLayoutEffect(function () {
    if (ref.current && ref.current.parentElement && !ref.current.parentElement.style.position) {
      ref.current.parentElement.style.position = 'relative';
    }
  });
  return React.createElement("div", Object.assign({
    ref: ref
  }, rest, {
    className: "ReactChart " + (className || ''),
    style: _extends({
      width: width,
      height: height,
      position: 'absolute'
    }, style),
    onClick: getOnClick() ? function (e) {
      return getOnClick()(focused, e);
    } : undefined
  }), React.createElement("svg", {
    ref: svgRef,
    style: {
      width: width,
      height: height,
      overflow: 'hidden'
    },
    onMouseEnter: function onMouseEnter(e) {
      return e.persist() || _onMouseMove(e);
    },
    onMouseMove: function onMouseMove(e) {
      return e.persist() || _onMouseMove(e);
    },
    onMouseLeave: function onMouseLeave(e) {
      return e.persist() || _onMouseLeave();
    },
    onMouseDown: function onMouseDown(e) {
      return e.persist() || _onMouseDown();
    }
  }, width && height ? React.createElement(React.Fragment, null, React.createElement("g", {
    style: {
      transform: translate(gridX, gridY)
    }
  }, React.createElement(Rectangle // To ensure the pointer always has something to hit
  , {
    // To ensure the pointer always has something to hit
    x1: -gridX,
    x2: width - gridX,
    y1: -gridY,
    y2: height - gridY,
    style: {
      opacity: 0
    }
  }), React.createElement(Voronoi$1, null), React.createElement("g", {
    className: "axes"
  }, [].concat(primaryAxes, secondaryAxes).map(function (axis) {
    return React.createElement(Axis, Object.assign({
      key: axis.id
    }, axis));
  })), React.createElement("g", {
    className: "Series",
    style: {
      pointerEvents: 'none'
    }
  }, stacks)), renderSVG ? renderSVG() : null) : null), React.createElement(Cursor, {
    primary: true
  }), React.createElement(Cursor, null), React.createElement(Brush, null), React.createElement(Tooltip, null));
});

var useMaterializeData = (function (_ref) {
  var data = _ref.data;
  return React.useMemo(function () {
    var materializedData = []; // First access the data, and provide it to the context

    for (var seriesIndex = 0; seriesIndex < data.length; seriesIndex++) {
      var _originalSeries$id, _originalSeries$label;

      var originalSeries = data[seriesIndex];
      var seriesId = (_originalSeries$id = originalSeries.id) != null ? _originalSeries$id : seriesIndex;
      var seriesLabel = (_originalSeries$label = originalSeries.label) != null ? _originalSeries$label : "Series " + (seriesIndex + 1);
      var primaryAxisId = originalSeries.primaryAxisId;
      var secondaryAxisId = originalSeries.secondaryAxisId;
      var originalDatums = originalSeries.data;
      var datums = [];

      for (var datumIndex = 0; datumIndex < originalDatums.length; datumIndex++) {
        var originalDatum = originalDatums[datumIndex];
        datums[datumIndex] = {
          originalSeries: originalSeries,
          seriesIndex: seriesIndex,
          seriesId: seriesId,
          seriesLabel: seriesLabel,
          index: datumIndex,
          originalDatum: originalDatum,
          primary: originalDatum.primary,
          secondary: originalDatum.secondary,
          radius: originalDatum.radius
        };
      }

      materializedData[seriesIndex] = {
        originalSeries: originalSeries,
        index: seriesIndex,
        id: seriesId,
        label: seriesLabel,
        primaryAxisId: primaryAxisId,
        secondaryAxisId: secondaryAxisId,
        datums: datums
      };
    }

    return materializedData;
  }, [data]);
});

function useSeriesStyle(series) {
  var _useChartContext = useChartContext(),
      focused = _useChartContext.focused,
      getSeriesStyle = _useChartContext.getSeriesStyle;

  return series.getStatusStyle(focused, getSeriesStyle);
}

function useDatumStyle(datum) {
  var _useChartContext = useChartContext(),
      focused = _useChartContext.focused,
      getDatumStyle = _useChartContext.getDatumStyle;

  return datum.getStatusStyle(focused, getDatumStyle);
}

var defaultStyle$4 = {
  r: 2,
  strokeWidth: '1',
  stroke: '#000000',
  fill: '#000000',
  opacity: 1
};
var Circle = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var style = _ref.style,
      rest = _objectWithoutPropertiesLoose(_ref, ["style"]);

  var resolvedStyle = _extends({}, defaultStyle$4, style);

  return React.createElement("circle", Object.assign({
    ref: ref
  }, rest, {
    style: resolvedStyle
  }));
});

var pathDefaultStyle = {
  strokeWidth: 2
};
var circleDefaultStyle = {
  r: 2
};
function Line$1(_ref) {
  var series = _ref.series,
      showPoints = _ref.showPoints,
      curve = _ref.curve;
  var lineFn = React.useMemo(function () {
    return line().x(function (d) {
      return d.x;
    }).y(function (d) {
      return d.y;
    }).defined(function (d) {
      return d.defined;
    }).curve(curve);
  }, [curve]);
  var path = React.useMemo(function () {
    return lineFn(series.datums);
  }, [lineFn, series.datums]);
  var style = useSeriesStyle(series);
  var pathProps = {
    d: path,
    style: _extends({}, pathDefaultStyle, style, style.line, {
      fill: 'none'
    })
  };
  return React.createElement("g", null, React.createElement(Path$2, Object.assign({}, pathProps)), showPoints && series.datums.map(function (datum, i) {
    return React.createElement(Point, Object.assign({}, {
      key: i,
      datum: datum,
      style: style
    }));
  }));
}
Line$1.defaultProps = {
  curve: curveMonotoneX
};

Line$1.plotDatum = function (datum, _ref2) {
  var primaryAxis = _ref2.primaryAxis,
      secondaryAxis = _ref2.secondaryAxis,
      xAxis = _ref2.xAxis,
      yAxis = _ref2.yAxis;
  datum.primaryCoord = primaryAxis.scale(datum.primary);
  datum.secondaryCoord = secondaryAxis.scale(datum.secondary);
  datum.x = xAxis.scale(datum.xValue);
  datum.y = yAxis.scale(datum.yValue);
  datum.defined = isValidPoint(datum.xValue) && isValidPoint(datum.yValue);
  datum.base = primaryAxis.vertical ? xAxis.scale(datum.baseValue) : yAxis.scale(datum.baseValue); // Adjust non-bar elements for ordinal scales

  if (xAxis.type === 'ordinal') {
    datum.x += xAxis.tickOffset;
  }

  if (yAxis.type === 'ordinal') {
    datum.y += yAxis.tickOffset;
  } // Set the default anchor point


  datum.anchor = {
    x: datum.x,
    y: datum.y
  }; // Set the pointer points (used in voronoi)

  datum.boundingPoints = [datum.anchor];
};

Line$1.buildStyles = function (series, _ref3) {
  var defaultColors = _ref3.defaultColors;
  var defaults = {
    // Pass some sane defaults
    color: defaultColors[series.index % (defaultColors.length - 1)]
  };
  buildStyleGetters(series, defaults);
};

function Point(_ref4) {
  var datum = _ref4.datum,
      style = _ref4.style;

  var _useChartState = useChartState(function () {
    return null;
  }),
      setChartState = _useChartState[1];

  var dataStyle = useDatumStyle(datum);
  var circleProps = {
    x: datum ? datum.x : undefined,
    y: datum ? datum.y : undefined,
    style: _extends({}, circleDefaultStyle, style, style.circle, dataStyle, dataStyle.circle),
    onMouseEnter: React.useCallback(function (e) {
      return setChartState(function (state) {
        return _extends({}, state, {
          element: datum
        });
      });
    }, [datum, setChartState]),
    onMouseLeave: React.useCallback(function (e) {
      return setChartState(function (state) {
        return _extends({}, state, {
          element: null
        });
      });
    }, [setChartState])
  };

  if (!datum.defined) {
    return null;
  }

  return React.createElement(Circle, Object.assign({}, circleProps));
}

var circleDefaultStyle$1 = {
  r: 2
};
function Bubble(_ref) {
  var series = _ref.series;
  var style = useSeriesStyle(series);
  return React.createElement("g", null, series.datums.map(function (datum, i) {
    return React.createElement(Point$1, Object.assign({}, {
      key: i,
      datum: datum,
      style: style
    }));
  }));
}

Bubble.plotDatum = function (datum, _ref2) {
  var primaryAxis = _ref2.primaryAxis,
      secondaryAxis = _ref2.secondaryAxis,
      xAxis = _ref2.xAxis,
      yAxis = _ref2.yAxis;
  datum.primaryCoord = primaryAxis.scale(datum.primary);
  datum.secondaryCoord = secondaryAxis.scale(datum.secondary);
  datum.x = xAxis.scale(datum.xValue);
  datum.y = yAxis.scale(datum.yValue);
  datum.defined = isValidPoint(datum.xValue) && isValidPoint(datum.yValue);
  datum.base = primaryAxis.vertical ? xAxis.scale(datum.baseValue) : yAxis.scale(datum.baseValue); // Adjust non-bar elements for ordinal scales

  if (xAxis.type === 'ordinal') {
    datum.x += xAxis.tickOffset;
  }

  if (yAxis.type === 'ordinal') {
    datum.y += yAxis.tickOffset;
  } // Set the default anchor point


  datum.anchor = {
    x: datum.x,
    y: datum.y,
    verticalPadding: datum.r,
    horizontalPadding: datum.r
  }; // Set the pointer points (used in voronoi)

  datum.boundingPoints = [datum.anchor];
};

Bubble.buildStyles = function (series, _ref3) {
  var defaultColors = _ref3.defaultColors;
  var defaults = {
    // Pass some sane defaults
    color: defaultColors[series.index % (defaultColors.length - 1)]
  };
  buildStyleGetters(series, defaults);
};

function Point$1(_ref4) {
  var datum = _ref4.datum,
      style = _ref4.style;
  var dataStyle = useDatumStyle(datum);

  var _useChartState = useChartState(function () {
    return null;
  }),
      setChartState = _useChartState[1];

  var circleProps = {
    x: datum ? datum.x : undefined,
    y: datum ? datum.y : undefined,
    style: _extends({}, circleDefaultStyle$1, typeof datum.radius !== 'undefined' ? {
      r: datum.radius
    } : {}, style, style.circle, dataStyle, dataStyle.circle),
    onMouseEnter: React.useCallback(function (e) {
      return setChartState(function (state) {
        return _extends({}, state, {
          element: datum
        });
      });
    }, [datum, setChartState]),
    onMouseLeave: React.useCallback(function (e) {
      return setChartState(function (state) {
        return _extends({}, state, {
          element: null
        });
      });
    }, [setChartState])
  };

  if (!datum.defined) {
    return null;
  }

  return React.createElement(Circle, Object.assign({}, circleProps));
}

var defaultAreaStyle = {
  strokeWidth: 0
};
var defaultLineStyle = {
  strokeWidth: 2
};
var circleDefaultStyle$2 = {
  r: 1.5
};
function Area(_ref) {
  var series = _ref.series,
      showOrphans = _ref.showOrphans,
      showPoints = _ref.showPoints,
      curve = _ref.curve;
  var areaFn = React.useMemo(function () {
    return area().x(function (d) {
      return d.x;
    }).y0(function (d) {
      return d.base;
    }).y1(function (d) {
      return d.y;
    }).defined(function (d) {
      return d.defined;
    }).curve(curve);
  }, [curve]);
  var lineFn = React.useMemo(function () {
    return line().x(function (d) {
      return d.x;
    }).y(function (d) {
      return d.y;
    }).defined(function (d) {
      return d.defined;
    }).curve(curve);
  }, [curve]);
  var areaPath = React.useMemo(function () {
    return areaFn(series.datums);
  }, [areaFn, series.datums]);
  var linePath = React.useMemo(function () {
    return lineFn(series.datums);
  }, [lineFn, series.datums]);
  var style = useSeriesStyle(series);
  var areaPathProps = {
    d: areaPath,
    style: _extends({}, defaultAreaStyle, style, style.area)
  };
  var linePathProps = {
    d: linePath,
    style: _extends({}, defaultLineStyle, style, style.line, {
      fill: 'none'
    })
  };
  return React.createElement("g", null, React.createElement(Path$2, Object.assign({}, areaPathProps)), React.createElement(Path$2, Object.assign({}, linePathProps)), showOrphans && series.datums.map(function (datum, index, all) {
    return React.createElement(OrphanLine, Object.assign({}, {
      key: index,
      datum: datum,
      style: style,
      all: all,
      index: index
    }));
  }), showPoints && series.datums.map(function (datum, i) {
    return React.createElement(Point$2, Object.assign({}, {
      key: i,
      datum: datum,
      style: style
    }));
  }));
}
Area.defaultProps = {
  showOrphans: true,
  showLine: true,
  showPoints: true,
  curve: curveLinear$1
};

Area.plotDatum = function (datum, _ref2) {
  var primaryAxis = _ref2.primaryAxis,
      secondaryAxis = _ref2.secondaryAxis,
      xAxis = _ref2.xAxis,
      yAxis = _ref2.yAxis;
  // Turn clamping on for secondaryAxis
  secondaryAxis.scale.clamp(true);
  datum.primaryCoord = primaryAxis.scale(datum.primary);
  datum.secondaryCoord = secondaryAxis.scale(datum.secondary);
  datum.x = xAxis.scale(datum.xValue);
  datum.y = yAxis.scale(datum.yValue);
  datum.defined = isValidPoint(datum.xValue) && isValidPoint(datum.yValue);
  datum.base = primaryAxis.vertical ? xAxis.scale(datum.baseValue) : yAxis.scale(datum.baseValue); // Turn clamping back off for secondaryAxis

  secondaryAxis.scale.clamp(false); // Adjust non-bar elements for ordinal scales

  if (xAxis.type === 'ordinal') {
    datum.x += xAxis.tickOffset;
  }

  if (yAxis.type === 'ordinal') {
    datum.y += yAxis.tickOffset;
  } // Set the default anchor point


  datum.anchor = {
    x: datum.x,
    y: datum.y
  }; // Set the pointer points (used in voronoi)

  datum.boundingPoints = [datum.anchor, {
    x: primaryAxis.vertical ? primaryAxis.position === 'left' ? datum.base - 1 : datum.base : datum.anchor.x,
    y: !primaryAxis.vertical ? primaryAxis.position === 'bottom' ? datum.base - 1 : datum.base : datum.anchor.y
  }];
};

Area.buildStyles = function (series, _ref3) {
  var defaultColors = _ref3.defaultColors;
  var defaults = {
    // Pass some sane defaults
    color: defaultColors[series.index % (defaultColors.length - 1)]
  };
  buildStyleGetters(series, defaults);
};

var OrphanLine = function OrphanLine(_ref4) {
  var datum = _ref4.datum,
      style = _ref4.style,
      all = _ref4.all,
      index = _ref4.index;
  var prev = all[index - 1] || {
    defined: false
  };
  var next = all[index + 1] || {
    defined: false
  };
  var dataStyle = useDatumStyle(datum);
  var lineProps = {
    x1: !datum || Number.isNaN(datum.x) ? null : datum.x,
    y1: !datum || Number.isNaN(datum.base) ? null : datum.base,
    x2: !datum || Number.isNaN(datum.x) ? null : datum.x,
    y2: !datum || Number.isNaN(datum.y) ? null : datum.y,
    style: _extends({}, defaultLineStyle, style, style.line, dataStyle, dataStyle.line)
  };

  if (!datum.defined || prev.defined || next.defined) {
    return null;
  }

  return React.createElement(Line, Object.assign({}, lineProps));
};

function Point$2(_ref5) {
  var datum = _ref5.datum,
      style = _ref5.style;

  var _useChartState = useChartState(function () {
    return null;
  }),
      setChartState = _useChartState[1];

  var dataStyle = useDatumStyle(datum);
  var circleProps = {
    x: datum ? datum.x : undefined,
    y: datum ? datum.y : undefined,
    style: _extends({}, circleDefaultStyle$2, style, style.circle, dataStyle, dataStyle.circle),
    onMouseEnter: React.useCallback(function (e) {
      return setChartState(function (state) {
        return _extends({}, state, {
          element: datum
        });
      });
    }, [datum, setChartState]),
    onMouseLeave: React.useCallback(function (e) {
      return setChartState(function (state) {
        return _extends({}, state, {
          element: null
        });
      });
    }, [setChartState])
  };

  if (!datum.defined) {
    return null;
  }

  return React.createElement(Circle, Object.assign({}, circleProps));
}

function Bar(_ref) {
  var series = _ref.series;

  var _useChartContext = useChartContext(),
      primaryAxes = _useChartContext.primaryAxes;

  var style = useSeriesStyle(series);

  var _ref2 = series.primaryAxisId ? primaryAxes.find(function (d) {
    return d.id === series.primaryAxisId;
  }) : primaryAxes[0],
      barOffset = _ref2.barOffset;

  return React.createElement("g", {
    className: "series bar"
  }, series.datums.map(function (datum, i) {
    return React.createElement(BarPiece, Object.assign({
      key: i
    }, {
      datum: datum,
      barOffset: barOffset,
      style: style
    }));
  }));
}

function BarPiece(_ref3) {
  var datum = _ref3.datum,
      barOffset = _ref3.barOffset,
      style = _ref3.style;

  var _useChartContext2 = useChartContext(),
      primaryAxes = _useChartContext2.primaryAxes;

  var _useChartState = useChartState(function () {
    return null;
  }),
      setChartState = _useChartState[1];

  var x = datum ? datum.x : 0;
  var y = datum ? datum.y : 0;
  var base = datum ? datum.base : 0;
  var size = Math.max(datum ? datum.size : 1, 1);
  var x1;
  var y1;
  var x2;
  var y2;

  if (primaryAxes.find(function (d) {
    return d.vertical;
  })) {
    x1 = base;
    x2 = x;
    y1 = y + barOffset;
    y2 = y1 + size;
  } else {
    x1 = x + barOffset;
    x2 = x1 + size;
    y1 = y;
    y2 = base;
  }

  var dataStyle = useDatumStyle(datum);
  var rectangleProps = {
    style: _extends({
      pointerEvents: 'all'
    }, style, style.rectangle, dataStyle, dataStyle.rectangle),
    x1: Number.isNaN(x1) ? null : x1,
    y1: Number.isNaN(y1) ? null : y1,
    x2: Number.isNaN(x2) ? null : x2,
    y2: Number.isNaN(y2) ? null : y2,
    onMouseEnter: React.useCallback(function (e) {
      return setChartState(function (state) {
        return _extends({}, state, {
          element: datum
        });
      });
    }, [datum, setChartState]),
    onMouseLeave: React.useCallback(function (e) {
      return setChartState(function (state) {
        return _extends({}, state, {
          element: null
        });
      });
    }, [setChartState])
  };
  return React.createElement(Rectangle, Object.assign({}, rectangleProps));
}

Bar.plotDatum = function (datum, _ref4) {
  var xAxis = _ref4.xAxis,
      yAxis = _ref4.yAxis,
      primaryAxis = _ref4.primaryAxis,
      secondaryAxis = _ref4.secondaryAxis;
  // Turn clamping on for secondaryAxis
  secondaryAxis.scale.clamp(true);
  datum.primaryCoord = primaryAxis.scale(datum.primary);
  datum.secondaryCoord = secondaryAxis.scale(datum.secondary);
  datum.x = xAxis.scale(datum.xValue);
  datum.y = yAxis.scale(datum.yValue);
  datum.defined = isValidPoint(datum.xValue) && isValidPoint(datum.yValue);
  datum.base = secondaryAxis.scale(datum.baseValue);
  datum.size = primaryAxis.barSize; // Turn clamping back off for secondaryAxis

  secondaryAxis.scale.clamp(false);

  if (!secondaryAxis.stacked) {
    datum.size = primaryAxis.seriesBarSize; // Use the seriesTypeIndex here in case we have mixed types.

    var seriesBandScaleOffset = primaryAxis.seriesBandScale(datum.seriesTypeIndex);

    if (secondaryAxis.vertical) {
      datum.x += seriesBandScaleOffset;
    } else {
      datum.y += seriesBandScaleOffset;
    }
  } // Set the default anchor point


  datum.anchor = {
    x: datum.x,
    y: datum.y,
    horizontalPadding: secondaryAxis.vertical ? datum.size / 2 : 0,
    verticalPadding: secondaryAxis.vertical ? 0 : datum.size / 2
  }; // Adjust the anchor point for bars

  if (!primaryAxis.vertical) {
    datum.anchor.x += primaryAxis.type !== 'ordinal' ? 0 : datum.size / 2;
  } else {
    datum.anchor.y += primaryAxis.type !== 'ordinal' ? 0 : datum.size / 2;
  } // Set the pointer points (used in voronoi)


  datum.boundingPoints = [// End of bar
  datum.anchor, // Start of bar
  {
    x: primaryAxis.vertical ? primaryAxis.position === 'left' ? datum.base + 1 : datum.base : datum.anchor.x,
    y: !primaryAxis.vertical ? primaryAxis.position === 'bottom' ? datum.base - 1 : datum.base : datum.anchor.y
  }];
};

Bar.buildStyles = function (series, _ref5) {
  var defaultColors = _ref5.defaultColors;
  var defaults = {
    // Pass some sane defaults
    color: defaultColors[series.index % (defaultColors.length - 1)]
  };
  buildStyleGetters(series, defaults);
};

var seriesTypes = {
  line: Line$1,
  bubble: Bubble,
  area: Area,
  bar: Bar
};
var defaultSeries = {
  type: 'line',
  showPoints: true,
  showOrphans: true,
  curve: curveMonotoneX
};
var useSeriesOptions = (function (_ref) {
  var materializedData = _ref.materializedData,
      series = _ref.series;
  return React.useMemo(function () {
    return materializedData.map(function (s, seriesIndex) {
      var _defaultSeries = _extends({}, defaultSeries, typeof series === 'function' ? series(s, seriesIndex) : series),
          type = _defaultSeries.type,
          rest = _objectWithoutPropertiesLoose(_defaultSeries, ["type"]);

      var renderer = seriesTypes[type];

      if (!renderer) {
        throw new Error("Could not find a registered series type for " + type);
      }

      return _extends({}, rest, {
        type: type,
        renderer: renderer
      });
    });
  }, [materializedData, series]);
});

var useSeriesTypes = (function (_ref) {
  var materializedData = _ref.materializedData,
      seriesOptions = _ref.seriesOptions;
  return React.useMemo(function () {
    return materializedData.map(function (series, i) {
      series.Component = seriesOptions[i].renderer;
      return series;
    }).map(function (series, i, all) {
      var seriesTypeIndex = all.filter(function (d, j) {
        return j < i && d.Component === series.Component;
      }).length;
      return _extends({}, series, {
        seriesTypeIndex: seriesTypeIndex,
        datums: series.datums.map(function (datum) {
          return _extends({}, datum, {
            seriesTypeIndex: seriesTypeIndex
          });
        })
      });
    });
  }, [materializedData, seriesOptions]);
});

var sumAllDimensionProperties = function sumAllDimensionProperties(side, prop) {
  if (side === void 0) {
    side = {};
  }

  return Object.keys(side).reduce(function (sum, subside) {
    var _side$subside;

    return sum + ((_side$subside = side[subside]) == null ? void 0 : _side$subside[prop]) || 0;
  }, 0);
};

var useDimensions = (function (_ref) {
  var width = _ref.width,
      height = _ref.height,
      axisDimensions = _ref.axisDimensions;

  var _React$useMemo = React.useMemo(function () {
    // Left
    var _map = ['width', 'top', 'bottom'].map(function (prop) {
      return sumAllDimensionProperties(axisDimensions.left, prop);
    }),
        axesLeftWidth = _map[0],
        axesLeftTop = _map[1],
        axesLeftBottom = _map[2];

    var _map2 = ['width', 'top', 'bottom'].map(function (prop) {
      return sumAllDimensionProperties(axisDimensions.right, prop);
    }),
        axesRightWidth = _map2[0],
        axesRightTop = _map2[1],
        axesRightBottom = _map2[2];

    var _map3 = ['height', 'left', 'right'].map(function (prop) {
      return sumAllDimensionProperties(axisDimensions.top, prop);
    }),
        axesTopHeight = _map3[0],
        axesTopLeft = _map3[1],
        axesTopRight = _map3[2];

    var _map4 = ['height', 'left', 'right'].map(function (prop) {
      return sumAllDimensionProperties(axisDimensions.bottom, prop);
    }),
        axesBottomHeight = _map4[0],
        axesBottomLeft = _map4[1],
        axesBottomRight = _map4[2];

    var gridX = Math.max(axesLeftWidth, axesTopLeft, axesBottomLeft);
    var gridY = Math.max(axesTopHeight, axesLeftTop, axesRightTop);
    var gridWidth = Math.max(0, width - Math.max(axesLeftWidth, axesTopLeft, axesBottomLeft) - Math.max(axesRightWidth, axesTopRight, axesBottomRight));
    var gridHeight = Math.max(0, height - Math.max(axesTopHeight, axesLeftTop, axesRightTop) - Math.max(axesBottomHeight, axesLeftBottom, axesRightBottom));
    return {
      gridX: gridX,
      gridY: gridY,
      gridWidth: gridWidth,
      gridHeight: gridHeight
    };
  }, [width, height, axisDimensions]),
      gridX = _React$useMemo.gridX,
      gridY = _React$useMemo.gridY,
      gridWidth = _React$useMemo.gridWidth,
      gridHeight = _React$useMemo.gridHeight;

  return {
    gridX: gridX,
    gridY: gridY,
    gridWidth: gridWidth,
    gridHeight: gridHeight
  };
});

var _scales;
var scales = (_scales = {}, _scales[axisTypeLinear] = linear$1, _scales[axisTypeLog] = log, _scales[axisTypeTime] = time, _scales[axisTypeUtc] = utcTime, _scales[axisTypeOrdinal] = band, _scales);

var detectVertical = function detectVertical(d) {
  return [positionLeft, positionRight].indexOf(d) > -1;
};

var detectRTL = function detectRTL(d) {
  return [positionTop, positionRight].indexOf(d) > -1;
};

function buildAxisLinear(_ref) {
  var _ref$axis = _ref.axis,
      primary = _ref$axis.primary,
      type = _ref$axis.type,
      invert = _ref$axis.invert,
      position = _ref$axis.position,
      primaryAxisId = _ref$axis.primaryAxisId,
      _ref$axis$min = _ref$axis.min,
      userMin = _ref$axis$min === void 0 ? undefined : _ref$axis$min,
      _ref$axis$max = _ref$axis.max,
      userMax = _ref$axis$max === void 0 ? undefined : _ref$axis$max,
      _ref$axis$hardMin = _ref$axis.hardMin,
      hardMin = _ref$axis$hardMin === void 0 ? undefined : _ref$axis$hardMin,
      _ref$axis$hardMax = _ref$axis.hardMax,
      hardMax = _ref$axis$hardMax === void 0 ? undefined : _ref$axis$hardMax,
      _ref$axis$base = _ref$axis.base,
      base = _ref$axis$base === void 0 ? undefined : _ref$axis$base,
      _ref$axis$tickCount = _ref$axis.tickCount,
      tickCount = _ref$axis$tickCount === void 0 ? 10 : _ref$axis$tickCount,
      _ref$axis$minTickCoun = _ref$axis.minTickCount,
      minTickCount = _ref$axis$minTickCoun === void 0 ? 1 : _ref$axis$minTickCoun,
      _ref$axis$maxTickCoun = _ref$axis.maxTickCount,
      maxTickCount = _ref$axis$maxTickCoun === void 0 ? 99999999 : _ref$axis$maxTickCoun,
      _ref$axis$tickValues = _ref$axis.tickValues,
      tickValues = _ref$axis$tickValues === void 0 ? null : _ref$axis$tickValues,
      _ref$axis$format = _ref$axis.format,
      userFormat = _ref$axis$format === void 0 ? null : _ref$axis$format,
      _ref$axis$tickSizeInn = _ref$axis.tickSizeInner,
      tickSizeInner = _ref$axis$tickSizeInn === void 0 ? 6 : _ref$axis$tickSizeInn,
      _ref$axis$tickSizeOut = _ref$axis.tickSizeOuter,
      tickSizeOuter = _ref$axis$tickSizeOut === void 0 ? 6 : _ref$axis$tickSizeOut,
      _ref$axis$tickPadding = _ref$axis.tickPadding,
      tickPadding = _ref$axis$tickPadding === void 0 ? 10 : _ref$axis$tickPadding,
      _ref$axis$labelRotati = _ref$axis.labelRotation,
      labelRotation = _ref$axis$labelRotati === void 0 ? 60 : _ref$axis$labelRotati,
      _ref$axis$innerPaddin = _ref$axis.innerPadding,
      innerPadding = _ref$axis$innerPaddin === void 0 ? 0.2 : _ref$axis$innerPaddin,
      _ref$axis$outerPaddin = _ref$axis.outerPadding,
      outerPadding = _ref$axis$outerPaddin === void 0 ? 0.1 : _ref$axis$outerPaddin,
      _ref$axis$showGrid = _ref$axis.showGrid,
      showGrid = _ref$axis$showGrid === void 0 ? null : _ref$axis$showGrid,
      _ref$axis$showTicks = _ref$axis.showTicks,
      showTicks = _ref$axis$showTicks === void 0 ? true : _ref$axis$showTicks,
      _ref$axis$filterTicks = _ref$axis.filterTicks,
      filterTicks = _ref$axis$filterTicks === void 0 ? function (d) {
    return d;
  } : _ref$axis$filterTicks,
      _ref$axis$show = _ref$axis.show,
      show = _ref$axis$show === void 0 ? true : _ref$axis$show,
      _ref$axis$stacked = _ref$axis.stacked,
      stacked = _ref$axis$stacked === void 0 ? false : _ref$axis$stacked,
      userId = _ref$axis.id,
      userEstimatedTickSize = _ref$axis.estimatedTickSize,
      materializedData = _ref.materializedData,
      gridHeight = _ref.gridHeight,
      gridWidth = _ref.gridWidth;

  if (!position) {
    throw new Error("Chart axes must have a valid 'position' property");
  } // Detect some settings


  var valueKey = primary ? 'primary' : 'secondary';
  var groupKey = !primary && 'primary';
  var AxisIdKey = valueKey + "AxisId";
  var vertical = detectVertical(position);
  var RTL = detectRTL(position); // Right to left OR top to bottom

  var estimatedTickSize = (userEstimatedTickSize != null ? userEstimatedTickSize : vertical) ? 20 : 50;
  var id = userId || position + "_" + type;
  var isTimeType = [axisTypeTime, axisTypeUtc].includes(type); // TODO: Any sorting needs to happen here, else the min/max's might not line up correctly
  // First we need to find unique values, min/max values and negative/positive totals

  var uniqueVals = [];
  var min;
  var max;
  var negativeTotalByKey = {};
  var positiveTotalByKey = {};
  var domain; // Loop through each series

  for (var seriesIndex = 0; seriesIndex < materializedData.length; seriesIndex++) {
    if (materializedData[seriesIndex][AxisIdKey] && materializedData[seriesIndex][AxisIdKey] !== id) {
      continue;
    } // Loop through each datum


    for (var datumIndex = 0; datumIndex < materializedData[seriesIndex].datums.length; datumIndex++) {
      var datum = materializedData[seriesIndex].datums[datumIndex];
      var value = void 0;
      var key = groupKey ? datum[groupKey] : datumIndex; // For ordinal scales, unique the values

      if (type === axisTypeOrdinal) {
        if (uniqueVals.indexOf() === -1) {
          uniqueVals.push(materializedData[seriesIndex].datums[datumIndex][valueKey]);
        }
      } else if (type === axisTypeTime || type === axisTypeUtc) {
        value = +datum[valueKey];
      } else {
        value = datum[valueKey];
      } // Add to stack total


      if (stacked) {
        if (value > 0) {
          positiveTotalByKey[key] = typeof positiveTotalByKey[key] !== 'undefined' ? positiveTotalByKey[key] + value : value;
        } else {
          negativeTotalByKey[key] = typeof negativeTotalByKey[key] !== 'undefined' ? negativeTotalByKey[key] + value : value;
        }
      } else {
        // Find min/max
        min = typeof min !== 'undefined' ? Math.min(min, value) : value;
        max = typeof max !== 'undefined' ? Math.max(max, value) : value;
      }
    }
  }

  if (type === axisTypeOrdinal) {
    domain = uniqueVals;
  } else if (stacked) {
    domain = [Math.min.apply(Math, [0].concat(Object.values(negativeTotalByKey))), Math.max.apply(Math, [0].concat(Object.values(positiveTotalByKey)))];
  } else {
    domain = [min, max];
  } // Now we need to figure out the range


  var range = [0, vertical ? gridHeight : gridWidth]; // axes by default read from top to bottom and left to right

  if (vertical && !primary) {
    // Vertical secondary ranges get inverted by default
    range.reverse();
  } // Give the scale a home


  var scale; // If this is an ordinal or other primary axis, it needs to be able to display bars.

  var bandScale;
  var barSize = 0;
  var cursorSize = 0;
  var stepSize = 0;

  var seriesBandScale = function seriesBandScale(d) {
    return d;
  };

  var seriesBarSize = 1;

  if (type === axisTypeOrdinal || primary) {
    // Calculate a band axis that is similar and pass down the bandwidth
    // just in case.
    bandScale = band().domain(materializedData.reduce(function (prev, current) {
      return current.datums.length > prev.length ? current.datums : prev;
    }, []).map(function (d) {
      return d.primary;
    })).rangeRound(range, 0.1).padding(0);
    bandScale.paddingOuter(outerPadding).paddingInner(innerPadding);
    barSize = bandScale.bandwidth();

    if (type === axisTypeOrdinal) {
      cursorSize = barSize;
    } // barSize = bandScale.bandwidth()


    stepSize = bandScale.step(); // Create a seriesBandScale in case this axis isn't stacked

    seriesBandScale = band().paddingInner(innerPadding / 2).domain(materializedData.filter(function (d) {
      return d.Component === Bar;
    }).map(function (d, i) {
      return i;
    })).rangeRound([0, barSize]);
    seriesBarSize = seriesBandScale.bandwidth();
  }

  if (type === axisTypeOrdinal) {
    // If it's ordinal, just assign the bandScale we made
    scale = bandScale;
  } else {
    // Otherwise, create a new scale of the appropriate type
    scale = scales[type]();
  } // Set base, min, and max


  if (typeof base === 'number') {
    domain[0] = Math.min(domain[0], base);
    domain[1] = Math.max(domain[1], base);
  }

  if (typeof defaultMin === 'number') {
    domain[0] = Math.min(domain[0], userMin);
  }

  if (typeof defaultMax === 'number') {
    domain[1] = Math.max(domain[1], userMax);
  } // Set the domain


  scale.domain(domain); // If we're not using an ordinal scale, round the ticks to "nice" values

  if (type !== axisTypeOrdinal) {
    scale.nice();
  } // If hard min and max are set, override any "nice" rounding values


  if (typeof hardMin === 'number') {
    scale.domain([hardMin, scale.domain()[1]]);
  }

  if (typeof hardMax === 'number') {
    scale.domain([scale.domain()[0], hardMax]);
  } // Invert if necessary


  if (invert) {
    scale.domain([].concat(scale.domain()).reverse());
  } // Now set the range


  scale.range(range);
  var scaleFormat = scale.tickFormat ? scale.tickFormat() : identity;
  var format = userFormat ? function (value, index) {
    return userFormat(value, index, scaleFormat(value));
  } : scaleFormat;
  var resolvedTickCount = tickCount;
  var ticks = filterTicks(tickValues || (scale.ticks ? scale.ticks(resolvedTickCount) : scale.domain()));
  var scaleMax = position === positionBottom ? -gridHeight : position === positionLeft ? gridWidth : position === positionTop ? gridHeight : -gridWidth;
  var directionMultiplier = position === positionTop || position === positionLeft ? -1 : 1;
  var transform = !vertical ? translateX : translateY;
  var spacing = Math.max(tickSizeInner, 0) + tickPadding; // Pass down the axis config (including the scale itself) for posterity

  var axis = {
    id: id,
    primary: primary,
    type: type,
    invert: invert,
    position: position,
    primaryAxisId: primaryAxisId,
    hardMin: hardMin,
    hardMax: hardMax,
    base: base,
    isTimeType: isTimeType,
    tickCount: tickCount,
    minTickCount: minTickCount,
    maxTickCount: maxTickCount,
    tickValues: tickValues,
    tickSizeInner: tickSizeInner,
    tickSizeOuter: tickSizeOuter,
    tickPadding: tickPadding,
    labelRotation: labelRotation,
    innerPadding: innerPadding,
    outerPadding: outerPadding,
    showGrid: showGrid,
    showTicks: showTicks,
    show: show,
    stacked: stacked,
    scale: scale,
    uniqueVals: uniqueVals,
    vertical: vertical,
    RTL: RTL,
    barSize: barSize,
    cursorSize: cursorSize,
    stepSize: stepSize,
    seriesBandScale: seriesBandScale,
    seriesBarSize: seriesBarSize,
    domain: domain,
    range: range,
    max: scaleMax,
    directionMultiplier: directionMultiplier,
    transform: transform,
    ticks: ticks,
    format: format,
    spacing: spacing,
    estimatedTickSize: estimatedTickSize
  };

  if (type === axisTypeOrdinal) {
    axis.gridOffset = -(axis.stepSize * innerPadding) / 2;
    axis.tickOffset = axis.barSize / 2;
    axis.barOffset = 0;
  } else {
    axis.tickOffset = 0;
    axis.barOffset = -axis.barSize / 2;
  }

  return axis;
}

// import buildAxisPie from './buildAxis.pie'
function buildAxis (config) {
  // if (config.type === 'pie') {
  // return buildAxisPie(config)
  // }
  return buildAxisLinear(config);
}

var useAxes = (function (_ref) {
  var axes = _ref.axes,
      materializedData = _ref.materializedData,
      gridHeight = _ref.gridHeight,
      gridWidth = _ref.gridWidth;
  // Detect axes changes and build axes
  var prePrimaryAxes = axes.filter(function (d) {
    return d.primary;
  });
  var preSecondaryAxes = axes.filter(function (d) {
    return !d.primary;
  });
  var primaryAxesHashes = JSON.stringify(prePrimaryAxes);
  var secondaryAxesHashes = JSON.stringify(preSecondaryAxes); // Calculate primary axes

  var primaryAxes = React.useMemo(function () {
    return prePrimaryAxes.map(function (axis, i) {
      return buildAxis({
        axis: axis,
        materializedData: materializedData,
        gridWidth: gridWidth,
        gridHeight: gridHeight
      });
    });
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [primaryAxesHashes, materializedData, gridHeight, gridWidth]); // Calculate secondary axes

  var secondaryAxes = React.useMemo(function () {
    return preSecondaryAxes.map(function (axis, i) {
      return buildAxis({
        axis: axis,
        primaryAxes: primaryAxes,
        materializedData: materializedData,
        gridWidth: gridWidth,
        gridHeight: gridHeight
      });
    });
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [secondaryAxesHashes, materializedData, gridHeight, gridWidth]); // Make sure we're mapping x and y to the correct axes

  var xKey = primaryAxes.find(function (d) {
    return d.vertical;
  }) ? 'secondary' : 'primary';
  var yKey = primaryAxes.find(function (d) {
    return d.vertical;
  }) ? 'primary' : 'secondary';
  var xAxes = primaryAxes.find(function (d) {
    return d.vertical;
  }) ? secondaryAxes : primaryAxes;
  var yAxes = primaryAxes.find(function (d) {
    return d.vertical;
  }) ? primaryAxes : secondaryAxes;
  return {
    primaryAxes: primaryAxes,
    secondaryAxes: secondaryAxes,
    xKey: xKey,
    yKey: yKey,
    xAxes: xAxes,
    yAxes: yAxes
  };
});

var useStackData = (function (_ref) {
  var materializedData = _ref.materializedData,
      primaryAxes = _ref.primaryAxes,
      secondaryAxes = _ref.secondaryAxes,
      yAxes = _ref.yAxes,
      yKey = _ref.yKey,
      xAxes = _ref.xAxes,
      xKey = _ref.xKey,
      grouping = _ref.grouping,
      defaultColors = _ref.defaultColors;
  // Make stackData
  return React.useMemo(function () {
    // We need materializedData and both axes to continue
    if (!primaryAxes.length || !secondaryAxes.length) {
      throw new Error('A primary and secondary axis is required!');
    } // If the axes are ready, let's decorate the materializedData for visual plotting
    // "totals" are kept per secondaryAxis and used for bases if secondaryAxis stacking is enabled


    var scaleTotals = secondaryAxes.map(function () {
      return {};
    });
    materializedData.forEach(function (series) {
      var axisIndex = getAxisIndexByAxisId(secondaryAxes, series.secondaryAxisId);
      series.datums.forEach(function (datum) {
        scaleTotals[axisIndex][datum.primary] = {
          negative: 0,
          positive: 0
        };
      });
    }); // Determine the correct primary and secondary values for each axis
    // Also calculate bases and totals if either axis is stacked

    var stackData = materializedData.map(function (series) {
      var primaryAxisIndex = getAxisIndexByAxisId(primaryAxes, series.primaryAxisId);
      var primaryAxis = primaryAxes[primaryAxisIndex];
      var secondaryAxisIndex = getAxisIndexByAxisId(secondaryAxes, series.secondaryAxisId);
      var secondaryAxis = secondaryAxes[secondaryAxisIndex];
      return _extends({}, series, {
        primaryAxis: primaryAxis,
        secondaryAxis: secondaryAxis,
        datums: series.datums.map(function (d) {
          var datum = _extends({}, d, {
            primaryAxis: primaryAxis,
            secondaryAxis: secondaryAxis,
            xValue: d[xKey],
            yValue: d[yKey],
            baseValue: 0
          });

          if (secondaryAxis.stacked) {
            var start = scaleTotals[secondaryAxisIndex][d.primary]; // Stack the x or y values (according to axis positioning)

            if (primaryAxis.vertical) {
              // Is this a valid point?
              var validPoint = isValidPoint(datum.xValue); // Should we use positive or negative base?

              var totalKey = datum.xValue >= 0 ? 'positive' : 'negative'; // Assign the base

              datum.baseValue = start[totalKey]; // Add the value for a total

              datum.totalValue = datum.baseValue + (validPoint ? datum.xValue : 0); // Update the totals

              scaleTotals[secondaryAxisIndex][d.primary][totalKey] = datum.totalValue; // Make the total the new value

              datum.xValue = validPoint ? datum.totalValue : null;
            } else {
              // Is this a valid point?
              var _validPoint = isValidPoint(datum.yValue); // Should we use positive or negative base?


              var _totalKey = datum.yValue >= 0 ? 'positive' : 'negative'; // Assign the base


              datum.baseValue = start[_totalKey]; // Add the value to the base

              datum.totalValue = datum.baseValue + (_validPoint ? datum.yValue : 0); // Update the totals

              scaleTotals[secondaryAxisIndex][d.primary][_totalKey] = datum.totalValue; // Make the total the new value

              datum.yValue = _validPoint ? datum.totalValue : null;
            }
          }

          return datum;
        })
      });
    });
    stackData.forEach(function (series) {
      series.datums.forEach(function (datum) {
        datum.series = series;
      });
    }); // Use the plotDatum method on each series

    stackData.forEach(function (series, i) {
      if (!series.Component.plotDatum) {
        throw new Error("Could not find a [SeriesType].plotDatum() static method for the series Component above (index: " + i + ")");
      }

      var primaryAxisIndex = getAxisIndexByAxisId(primaryAxes, series.primaryAxisId);
      var secondaryAxisIndex = getAxisIndexByAxisId(secondaryAxes, series.secondaryAxisId);
      var primaryAxis = primaryAxes[primaryAxisIndex];
      var secondaryAxis = secondaryAxes[secondaryAxisIndex];
      var xAxisIndex = getAxisIndexByAxisId(xAxes, series[xKey + "AxisId"]);
      var yAxisIndex = getAxisIndexByAxisId(yAxes, series[yKey + "AxisId"]);
      var xAxis = xAxes[xAxisIndex];
      var yAxis = yAxes[yAxisIndex];
      series.datums = series.datums.map(function (d) {
        // Data for cartesian charts
        var result = series.Component.plotDatum(d, {
          primaryAxis: primaryAxis,
          secondaryAxis: secondaryAxis,
          xAxis: xAxis,
          yAxis: yAxis
        });
        return result || d;
      });
    }); // Do any data grouping ahead of time using

    if ([groupingSingle, groupingSeries].includes(grouping)) {
      for (var seriesIndex = 0; seriesIndex < stackData.length; seriesIndex++) {
        var series = stackData[seriesIndex];

        for (var datumIndex = 0; datumIndex < series.datums.length; datumIndex++) {
          var datum = series.datums[datumIndex];
          datum.group = grouping === groupingSeries ? datum.series.datums : [datum];
        }
      }
    } else if ([groupingPrimary, groupingSecondary].includes(grouping)) {
      var datumsByGrouping = {};

      for (var _seriesIndex = 0; _seriesIndex < stackData.length; _seriesIndex++) {
        var _series = stackData[_seriesIndex];

        for (var _datumIndex = 0; _datumIndex < _series.datums.length; _datumIndex++) {
          var _datum = _series.datums[_datumIndex];

          if (!_datum.defined) {
            continue;
          }

          var axisKey = String(grouping === groupingPrimary ? _datum.primary : _datum.secondary);
          datumsByGrouping[axisKey] = datumsByGrouping[axisKey] || [];
          datumsByGrouping[axisKey].push(_datum);
        }
      }

      for (var _seriesIndex2 = 0; _seriesIndex2 < stackData.length; _seriesIndex2++) {
        var _series2 = stackData[_seriesIndex2];

        for (var _datumIndex2 = 0; _datumIndex2 < _series2.datums.length; _datumIndex2++) {
          var _datum2 = _series2.datums[_datumIndex2];

          var _axisKey = String(grouping === groupingPrimary ? _datum2.primary : _datum2.secondary);

          _datum2.group = datumsByGrouping[_axisKey];
        }
      }
    } // Not we need to precalculate all of the possible status styles by
    // calling the seemingly 'live' getSeriesStyle, and getDatumStyle callbacks ;)


    stackData = stackData.map(function (series, i) {
      if (!series.Component.buildStyles) {
        throw new Error("Could not find a SeriesType.buildStyles() static method for the series Component above (index: " + i + ")");
      }

      var result = series.Component.buildStyles(series, {
        defaultColors: defaultColors
      });
      return result || series;
    });
    return stackData;
  }, [primaryAxes, secondaryAxes, materializedData, grouping, xKey, yKey, xAxes, yAxes, defaultColors]);
});

var showCount = 10;

function getSecondaryFormatter(datum, formatSecondary) {
  return formatSecondary || datum.secondaryAxis.format || function (val) {
    return Math.floor(val) < val ? Math.round(val * 100) / 100 : val;
  };
}

function TooltipRenderer(props) {
  var datum = props.datum,
      grouping = props.grouping,
      primaryAxis = props.primaryAxis,
      secondaryAxis = props.secondaryAxis,
      formatSecondary = props.formatSecondary,
      formatTertiary = props.formatTertiary,
      getStyle = props.getStyle,
      dark = props.dark,
      tooltip = props.tooltip;

  if (!datum) {
    return null;
  }

  var resolvedFormatTertiary = formatTertiary || function (val) {
    return Math.floor(val) < val ? Math.round(val * 100) / 100 : val;
  };

  var sortedGroupDatums = [].concat(datum.group).sort(function (a, b) {
    if (!primaryAxis.stacked && grouping === groupingSeries || grouping === groupingSecondary) {
      if (a.primaryCoord > b.primaryCoord) {
        return -1;
      } else if (a.primaryCoord < b.primaryCoord) {
        return 1;
      }
    } else if (!secondaryAxis.stacked) {
      if (a.secondaryCoord > b.secondaryCoord) {
        return -1;
      } else if (a.secondaryCoord < b.secondaryCoord) {
        return 1;
      }
    }

    return a.seriesIndex > b.seriesIndex ? 1 : -1;
  });

  if (grouping === groupingPrimary) {
    sortedGroupDatums.reverse();
  }

  if (secondaryAxis.invert) {
    sortedGroupDatums.reverse();
  }

  if (tooltip.invert) {
    sortedGroupDatums.reverse();
  }

  var resolvedShowCount =  showCount ;
  var length = sortedGroupDatums.length; // Get the focused series' index

  var activeIndex = sortedGroupDatums.findIndex(function (d) {
    return d === datum;
  }); // Get the start by going back half of the showCount

  var start = activeIndex > -1 ? activeIndex - resolvedShowCount / 2 : 0; // Make sure it's at least 0

  start = Math.max(start, 0); // Use the start and add the showCount to get the end

  var end = activeIndex > -1 ? start + resolvedShowCount : length; // Don't let the end go passed the length

  end = Math.min(end, length); // Double check we aren't clipping the start

  start = Math.max(end - resolvedShowCount, 0); // Slice the datums by start and end

  var visibleSortedGroupDatums = sortedGroupDatums.slice(start, end); // Detect if we have previous items

  var hasPrevious = start > 0; // Or next items

  var hasNext = end < length;
  return React.createElement("div", null, React.createElement("div", {
    style: {
      marginBottom: '3px',
      textAlign: 'center'
    }
  }, grouping === groupingSeries ? React.createElement("strong", null, datum.seriesLabel) : grouping === groupingSecondary ? React.createElement("strong", null, datum.secondaryAxis.format(datum.secondary)) : React.createElement("strong", null, datum.primaryAxis.format(datum.primary))), React.createElement("table", {
    style: {
      whiteSpace: 'nowrap'
    }
  }, React.createElement("tbody", null, hasPrevious ? React.createElement("tr", {
    style: {
      opacity: 0.8
    }
  }, React.createElement("td", null), React.createElement("td", null, "..."), React.createElement("td", null)) : null, visibleSortedGroupDatums.map(function (sortedDatum, i) {
    var active = sortedDatum === datum;
    var resolvedSecondaryFormat = getSecondaryFormatter(sortedDatum, formatSecondary);
    return React.createElement("tr", {
      key: i,
      style: {
        opacity: active ? 1 : 0.8,
        fontWeight: active && 'bold'
      }
    }, React.createElement("td", {
      style: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        marginRight: '5px'
      }
    }, React.createElement("svg", {
      width: "16",
      height: "16"
    }, React.createElement("circle", {
      cx: "8",
      cy: "8",
      r: "7",
      style: _extends({}, getStyle(sortedDatum), {
        stroke: dark ? 'black' : 'white',
        strokeWidth: active ? 2 : 1
      })
    }))), grouping === groupingSeries ? React.createElement(React.Fragment, null, React.createElement("td", null, primaryAxis.format(sortedDatum.primary), ": \xA0"), React.createElement("td", {
      style: {
        textAlign: 'right'
      }
    }, resolvedSecondaryFormat(sortedDatum.secondary, sortedDatum), sortedDatum.r ? " (" + resolvedFormatTertiary(sortedDatum.r) + ")" : null)) : grouping === groupingSecondary ? React.createElement(React.Fragment, null, React.createElement("td", null, sortedDatum.seriesLabel, ": \xA0"), React.createElement("td", {
      style: {
        textAlign: 'right'
      }
    }, primaryAxis.format(sortedDatum.primary), sortedDatum.r ? " (" + resolvedFormatTertiary(sortedDatum.r) + ")" : null)) : React.createElement(React.Fragment, null, React.createElement("td", null, sortedDatum.seriesLabel, ": \xA0"), React.createElement("td", {
      style: {
        textAlign: 'right'
      }
    }, resolvedSecondaryFormat(sortedDatum.secondary, sortedDatum), sortedDatum.r ? " (" + resolvedFormatTertiary(sortedDatum.r) + ")" : null)));
  }), hasNext ? React.createElement("tr", {
    style: {
      opacity: 0.8
    }
  }, React.createElement("td", null), React.createElement("td", null, "..."), React.createElement("td", null)) : null, secondaryAxis && secondaryAxis.stacked && datum.group.length > 1 ? React.createElement("tr", null, React.createElement("td", {
    style: {
      paddingTop: '5px'
    }
  }, React.createElement("div", {
    style: {
      width: '12px',
      height: '12px',
      backgroundColor: dark ? 'rgba(0, 26, 39, 0.3)' : 'rgba(255,255,255,.2)',
      borderRadius: '50px'
    }
  })), React.createElement("td", {
    style: {
      paddingTop: '5px'
    }
  }, "Total: \xA0"), React.createElement("td", {
    style: {
      paddingTop: '5px'
    }
  }, secondaryAxis.format([].concat(datum.group).reverse()[0].totalValue))) : null)));
}

var useTooltip = (function (_ref) {
  var focused = _ref.focused,
      tooltip = _ref.tooltip,
      pointer = _ref.pointer,
      gridWidth = _ref.gridWidth,
      gridHeight = _ref.gridHeight;
  return React.useMemo(function () {
    if (!tooltip) {
      return null;
    } // Default tooltip props
    // eslint-disable-next-line react-hooks/exhaustive-deps


    tooltip = _extends({
      align: alignAuto,
      alignPriority: [alignRight, alignTopRight, alignBottomRight, alignLeft, alignTopLeft, alignBottomLeft, alignTop, alignBottom],
      padding: 5,
      tooltipArrowPadding: 7,
      anchor: 'closest',
      render: TooltipRenderer,
      onChange: function onChange() {}
    }, tooltip);
    var anchor = {};
    var show = true; // If there is a focused datum, default the focus to its x and y

    if (focused) {
      anchor = focused.anchor;
    } else {
      show = false;
    }

    if (tooltip.anchor === 'pointer') {
      // Support pointer-bound focus
      anchor = pointer;
    } else if (tooltip.anchor === 'closest') ; else if (focused) {
      // Support manual definition of focus point using relative multiFocus strategy
      var multiFocus = Array.isArray(tooltip.anchor) ? [].concat(tooltip.anchor) : [tooltip.anchor];
      anchor = getMultiAnchor({
        anchor: multiFocus,
        points: focused.group,
        gridWidth: gridWidth,
        gridHeight: gridHeight
      });
    }

    anchor = anchor ? _extends({
      horizontalPadding: anchor.horizontalPadding || 0,
      verticalPadding: anchor.verticalPadding || 0
    }, anchor) : anchor;
    return _extends({}, tooltip, {
      anchor: anchor,
      show: show
    });
  }, [focused, gridHeight, gridWidth, pointer, tooltip]);
});

function getMultiAnchor(_ref2) {
  var anchor = _ref2.anchor,
      points = _ref2.points,
      gridWidth = _ref2.gridWidth,
      gridHeight = _ref2.gridHeight;

  var invalid = function invalid() {
    throw new Error(JSON.stringify(anchor) + " is not a valid tooltip anchor option. You should use a single anchor option or 2 non-conflicting anchor options.");
  };

  var x;
  var y;
  var xMin = points[0].anchor.x;
  var xMax = points[0].anchor.x;
  var yMin = points[0].anchor.y;
  var yMax = points[0].anchor.y;
  points.forEach(function (point) {
    xMin = Math.min(point.anchor.x, xMin);
    xMax = Math.max(point.anchor.x, xMax);
    yMin = Math.min(point.anchor.y, yMin);
    yMax = Math.max(point.anchor.y, yMax);
  });

  if (anchor.length > 2) {
    return invalid();
  }

  anchor = anchor.sort(function (a) {
    return a.includes('center') || a.includes('Center') ? 1 : -1;
  });

  for (var i = 0; i < anchor.length; i++) {
    var anchorPart = anchor[i]; // Horizontal Positioning

    if (['left', 'right', 'gridLeft', 'gridRight'].includes(anchorPart)) {
      if (typeof x !== 'undefined') {
        invalid();
      }

      if (anchorPart === 'left') {
        x = xMin;
      } else if (anchorPart === 'right') {
        x = xMax;
      } else if (anchorPart === 'gridLeft') {
        x = 0;
      } else if (anchorPart === 'gridRight') {
        x = gridWidth;
      } else {
        invalid();
      }
    } // Vertical Positioning


    if (['top', 'bottom', 'gridTop', 'gridBottom'].includes(anchorPart)) {
      if (typeof y !== 'undefined') {
        invalid();
      }

      if (anchorPart === 'top') {
        y = yMin;
      } else if (anchorPart === 'bottom') {
        y = yMax;
      } else if (anchorPart === 'gridTop') {
        y = 0;
      } else if (anchorPart === 'gridBottom') {
        y = gridHeight;
      } else {
        invalid();
      }
    } // Center Positioning


    if (['center', 'gridCenter'].includes(anchorPart)) {
      if (anchorPart === 'center') {
        if (typeof y === 'undefined') {
          y = (yMin + yMax) / 2;
        }

        if (typeof x === 'undefined') {
          x = (xMin + xMax) / 2;
        }
      } else if (anchorPart === 'gridCenter') {
        if (typeof y === 'undefined') {
          y = gridHeight / 2;
        }

        if (typeof x === 'undefined') {
          x = gridWidth / 2;
        }
      } else {
        invalid();
      }
    } // Auto center the remainder if there is only one anchorPart listed


    if (anchor.length === 1) {
      if (anchor[0].includes('grid')) {
        anchor.push('gridCenter');
      } else {
        anchor.push('center');
      }
    }
  }

  return {
    x: x,
    y: y
  };
}

var defaultCursorProps = {
  render: function render(_ref) {
    var formattedValue = _ref.formattedValue;
    return React.createElement("span", null, formattedValue);
  },
  snap: true,
  showLine: true,
  showLabel: true,
  axisId: undefined,
  onChange: function onChange() {}
};
var useCursors = (function (_ref2) {
  var primaryCursor = _ref2.primaryCursor,
      secondaryCursor = _ref2.secondaryCursor,
      primaryAxes = _ref2.primaryAxes,
      secondaryAxes = _ref2.secondaryAxes,
      focused = _ref2.focused,
      pointer = _ref2.pointer,
      gridWidth = _ref2.gridWidth,
      gridHeight = _ref2.gridHeight,
      stackData = _ref2.stackData;
  return [primaryCursor, secondaryCursor].map(function (cursor, i) {
    var cursorValue = cursor && cursor.value;
    return React.useMemo(function () {
      if (!cursor) {
        return;
      }

      var primary = i === 0; // eslint-disable-next-line react-hooks/exhaustive-deps

      cursor = _extends({}, defaultCursorProps, cursor, {
        primary: primary
      });
      var value;
      var show = false; // Determine the axis to use

      var axis = getAxisByAxisId(primary ? primaryAxes : secondaryAxes, cursor.axisId || focused ? focused.series[primary ? 'primaryAxisId' : 'secondaryAxisId'] : undefined);
      var siblingAxis = primary ? secondaryAxes[0] : primaryAxes[0]; // Resolve the invert function

      var invert = axis.scale.invert || function (d) {
        return d;
      }; // If the pointer is active, try to show


      if (pointer.active) {
        // Default to cursor x and y
        var x = pointer.x;
        var y = pointer.y; // If the cursor isn't in the grid, don't display

        if (x < -1 || x > gridWidth + 1 || y < -1 || y > gridHeight + 1) {
          show = false;
        } else {
          show = true;
        } // Implement snapping


        if (axis.type === 'ordinal' || cursor.snap) {
          if (!focused) {
            show = false;
          } else {
            if (axis.vertical) {
              value = focused.yValue;
            } else {
              value = focused.xValue;
            }
          }
        } else if (axis.vertical) {
          value = invert(y);
        } else {
          value = invert(x);
        }
      } else {
        show = false;
      }

      var resolvedShow = show;
      var resolvedValue = value;

      if (typeof cursor.value !== 'undefined' && cursor.value !== null) {
        resolvedValue = cursor.value;

        if (typeof cursor.show !== 'undefined') {
          resolvedShow = cursor.show;
        } else {
          resolvedShow = true;
        }

        if (typeof axis.scale(resolvedValue) === 'undefined') {
          resolvedShow = false;
        }
      }

      return _extends({}, cursor, {
        axis: axis,
        siblingAxis: siblingAxis,
        show: show,
        value: value,
        resolvedShow: resolvedShow,
        resolvedValue: resolvedValue
      });
    }, [stackData, pointer, cursorValue]);
  });
});

var defaultColorScheme = ['#0f83ab', '#faa43a', '#ff4e4e', '#53cfc9', '#a2d925', '#decf3f', '#734fe9', '#cd82ad', '#006d92', '#de7c00', '#f33232', '#3f9a80', '#53c200', '#d7af00', '#4c26c9', '#d44d99'];

function applyDefaults(_ref) {
  var _ref$getSeriesStyle = _ref.getSeriesStyle,
      getSeriesStyle = _ref$getSeriesStyle === void 0 ? function () {
    return {};
  } : _ref$getSeriesStyle,
      _ref$getDatumStyle = _ref.getDatumStyle,
      getDatumStyle = _ref$getDatumStyle === void 0 ? function () {
    return {};
  } : _ref$getDatumStyle,
      _ref$getSeriesOrder = _ref.getSeriesOrder,
      getSeriesOrder = _ref$getSeriesOrder === void 0 ? function (d) {
    return d;
  } : _ref$getSeriesOrder,
      _ref$grouping = _ref.grouping,
      grouping = _ref$grouping === void 0 ? groupingPrimary : _ref$grouping,
      _ref$focus = _ref.focus,
      focus = _ref$focus === void 0 ? focusAuto : _ref$focus,
      _ref$showVoronoi = _ref.showVoronoi,
      showVoronoi = _ref$showVoronoi === void 0 ? false : _ref$showVoronoi,
      _ref$defaultColors = _ref.defaultColors,
      defaultColors = _ref$defaultColors === void 0 ? defaultColorScheme : _ref$defaultColors,
      rest = _objectWithoutPropertiesLoose(_ref, ["getSeriesStyle", "getDatumStyle", "getSeriesOrder", "grouping", "focus", "showVoronoi", "defaultColors"]);

  return _extends({
    getSeriesStyle: getSeriesStyle,
    getDatumStyle: getDatumStyle,
    getSeriesOrder: getSeriesOrder,
    grouping: grouping,
    focus: focus,
    showVoronoi: showVoronoi,
    defaultColors: defaultColors
  }, rest);
}

function useCreateStore(initialState) {
  var storeRef = React.useRef();

  if (!storeRef.current) {
    storeRef.current = createChartState(initialState);
  }

  return storeRef.current;
}

function ChartState(options) {
  var _useCreateStore = useCreateStore(function (setState) {
    var setOffset = function setOffset(updater) {
      return setState(function (old) {
        var _newOffset$left, _newOffset$top;

        var newOffset = functionalUpdate(updater, old.offset);
        return _extends({}, old, {
          offset: {
            left: (_newOffset$left = newOffset.left) != null ? _newOffset$left : 0,
            top: (_newOffset$top = newOffset.top) != null ? _newOffset$top : 0
          }
        });
      });
    };

    return {
      focused: null,
      element: null,
      axisDimensions: {},
      offset: {},
      pointer: {},
      setOffset: setOffset
    };
  }),
      StateProvider = _useCreateStore.Provider;

  return React.createElement(ParentSize, null, function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return React.createElement(StateProvider, null, React.createElement(Chart, Object.assign({}, _extends({}, options, {
      width: width,
      height: height
    }))));
  });
}
function Chart(options) {
  var _applyDefaults = applyDefaults(options),
      width = _applyDefaults.width,
      height = _applyDefaults.height,
      data = _applyDefaults.data,
      grouping = _applyDefaults.grouping,
      focus = _applyDefaults.focus,
      showVoronoi = _applyDefaults.showVoronoi,
      dark = _applyDefaults.dark,
      series = _applyDefaults.series,
      axes = _applyDefaults.axes,
      primaryCursor = _applyDefaults.primaryCursor,
      secondaryCursor = _applyDefaults.secondaryCursor,
      tooltip = _applyDefaults.tooltip,
      brush = _applyDefaults.brush,
      renderSVG = _applyDefaults.renderSVG,
      getSeriesStyleOriginal = _applyDefaults.getSeriesStyle,
      getDatumStyle = _applyDefaults.getDatumStyle,
      onClick = _applyDefaults.onClick,
      onFocus = _applyDefaults.onFocus,
      getSeriesOrder = _applyDefaults.getSeriesOrder,
      defaultColors = _applyDefaults.defaultColors,
      rest = _objectWithoutPropertiesLoose(_applyDefaults, ["width", "height", "data", "grouping", "focus", "showVoronoi", "dark", "series", "axes", "primaryCursor", "secondaryCursor", "tooltip", "brush", "renderSVG", "getSeriesStyle", "getDatumStyle", "onClick", "onFocus", "getSeriesOrder", "defaultColors"]);

  var _useChartState = useChartState(function (d) {
    return {
      focused: d.focused,
      element: d.element,
      axisDimensions: d.axisDimensions,
      pointer: d.pointer
    };
  }, 'shallow'),
      _useChartState$ = _useChartState[0],
      focused = _useChartState$.focused,
      element = _useChartState$.element,
      axisDimensions = _useChartState$.axisDimensions,
      pointer = _useChartState$.pointer;

  var responsiveElRef = React.useRef();
  var getOnClick = useGetLatest(onClick);
  var getOnFocus = useGetLatest(onFocus);
  var materializedData = useMaterializeData({
    data: data
  });
  var seriesOptions = useSeriesOptions({
    materializedData: materializedData,
    series: series
  });
  materializedData = useSeriesTypes({
    materializedData: materializedData,
    seriesOptions: seriesOptions
  });

  var _useDimensions = useDimensions({
    width: width,
    height: height,
    axisDimensions: axisDimensions
  }),
      gridX = _useDimensions.gridX,
      gridY = _useDimensions.gridY,
      gridWidth = _useDimensions.gridWidth,
      gridHeight = _useDimensions.gridHeight;

  var _useAxes = useAxes({
    axes: axes,
    materializedData: materializedData,
    gridHeight: gridHeight,
    gridWidth: gridWidth
  }),
      primaryAxes = _useAxes.primaryAxes,
      secondaryAxes = _useAxes.secondaryAxes,
      xKey = _useAxes.xKey,
      yKey = _useAxes.yKey,
      xAxes = _useAxes.xAxes,
      yAxes = _useAxes.yAxes;

  var stackData = useStackData({
    materializedData: materializedData,
    primaryAxes: primaryAxes,
    secondaryAxes: secondaryAxes,
    yAxes: yAxes,
    yKey: yKey,
    xAxes: xAxes,
    xKey: xKey,
    grouping: grouping,
    defaultColors: defaultColors
  });
  focused = React.useMemo(function () {
    // Get the closest focus datum out of the datum group
    if (focused || element) {
      var resolvedFocus = focus;

      if (focus === focusAuto) {
        if (element) {
          resolvedFocus = focusElement;
        } else {
          resolvedFocus = focusClosest;
        }
      }

      if (resolvedFocus === focusElement && element) {
        return element;
      } else if (resolvedFocus === focusClosest) {
        return getClosestPoint(pointer, focused.group);
      }
    }

    return null;
  }, [element, focus, focused, pointer]); // keep the previous focused value around for animations

  var latestFocused = useLatest(focused, focused); // Calculate Tooltip

  tooltip = useTooltip({
    focused: focused,
    tooltip: tooltip,
    pointer: pointer,
    gridWidth: gridWidth,
    gridHeight: gridHeight
  }); // Cursors

  var _useCursors = useCursors({
    primaryCursor: primaryCursor,
    secondaryCursor: secondaryCursor,
    primaryAxes: primaryAxes,
    secondaryAxes: secondaryAxes,
    focused: focused,
    pointer: pointer,
    gridWidth: gridWidth,
    gridHeight: gridHeight,
    stackData: stackData
  });

  primaryCursor = _useCursors[0];
  secondaryCursor = _useCursors[1];
  var getSeriesStyle = React.useCallback(function (series) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return _extends({
      color: series.originalSeries.color
    }, getSeriesStyleOriginal.apply(void 0, [series].concat(args)));
  }, [getSeriesStyleOriginal]);
  var contextValue = {
    latestFocused: latestFocused,
    focused: focused,
    tooltip: tooltip,
    width: width,
    height: height,
    brush: brush,
    grouping: grouping,
    showVoronoi: showVoronoi,
    materializedData: materializedData,
    stackData: stackData,
    primaryAxes: primaryAxes,
    secondaryAxes: secondaryAxes,
    primaryCursor: primaryCursor,
    secondaryCursor: secondaryCursor,
    gridX: gridX,
    gridY: gridY,
    gridWidth: gridWidth,
    gridHeight: gridHeight,
    dark: dark,
    renderSVG: renderSVG,
    xKey: xKey,
    yKey: yKey,
    xAxes: xAxes,
    yAxes: yAxes,
    getOnClick: getOnClick,
    getSeriesStyle: getSeriesStyle,
    getDatumStyle: getDatumStyle,
    seriesOptions: seriesOptions,
    getSeriesOrder: getSeriesOrder
  };
  React.useEffect(function () {
    if (getOnFocus()) {
      getOnFocus()(focused);
    }
  }, [focused, getOnFocus]);
  var previousDragging = usePrevious(pointer.dragging);
  React.useEffect(function () {
    if (brush != null && brush.onSelect && previousDragging && !pointer.dragging) {
      if (Math.abs(pointer.sourceX - pointer.x) < 20) {
        return;
      }

      brush.onSelect({
        pointer: pointer.released,
        start: primaryAxes[0].scale.invert(pointer.sourceX),
        end: primaryAxes[0].scale.invert(pointer.x)
      });
    }
  }, [brush, pointer.dragging, pointer.released, pointer.sourceX, pointer.x, previousDragging, primaryAxes]);
  return React.createElement(ChartContextProvider, {
    value: contextValue
  }, React.createElement(ChartInner, Object.assign({
    ref: responsiveElRef
  }, rest)));
}

export { ChartState as Chart, alignAuto, alignBottom, alignBottomLeft, alignBottomRight, alignLeft, alignRight, alignTop, alignTopLeft, alignTopRight, anchorBottom, anchorCenter, anchorClosest, anchorGridBottom, anchorGridLeft, anchorGridRight, anchorGridTop, anchorLeft, anchorPointer, anchorRight, anchorTop, axisTypeLinear, axisTypeLog, axisTypeOrdinal, axisTypeTime, axisTypeUtc, focusAuto, focusClosest, focusElement, groupingPrimary, groupingSecondary, groupingSeries, groupingSingle, positionBottom, positionLeft, positionRight, positionTop, useChartState };
//# sourceMappingURL=react-charts.esm.js.map
